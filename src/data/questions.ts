import { QuizletQuestionCategoryEnum } from '../models/category.model';
import { QuizletQuestion } from '../models/question.model';

export const QUIZLET_QUESTIONS: QuizletQuestion[] = [
  {
    id: 1,
    title: 'Какие бывают методы HTTP-запросов?',
    category: [QuizletQuestionCategoryEnum.common],
    level: 1,
    links: [
      {
        label: 'Про HTTP',
        href: 'https://developer.mozilla.org/ru/docs/Web/HTTP',
      },
    ],
    answer: `
        <dl>
          <dt>
            <code>
              <a href="/ru/docs/Web/HTTP/Methods/GET">GET</a>
            </code>
          </dt>
          <dd>
            Метод <code>GET</code> запрашивает представление ресурса. Запросы с
            использованием этого метода могут только извлекать данные.
          </dd>
          <dt>
            <code>
              <a href="/en-US/docs/Web/HTTP/Methods/HEAD">HEAD</a>
            </code>
          </dt>
          <dd>
            <code>HEAD</code> запрашивает ресурс так же, как и метод GET, но без
            тела ответа.
          </dd>
          <dt>
            <code>
              <a href="/ru/docs/Web/HTTP/Methods/POST">POST</a>
            </code>
          </dt>
          <dd>
            <code>POST</code> используется для отправки сущностей к
            определённому ресурсу. Часто вызывает изменение состояния или
            какие-то побочные эффекты на сервере.
          </dd>
          <dt>
            <code>
              <a href="/ru/docs/Web/HTTP/Methods/PUT">PUT</a>
            </code>
          </dt>
          <dd>
            <p>
              <code>PUT</code> заменяет все текущие представления ресурса
              данными запроса.
            </p>
          </dd>
          <dt>
            <code>
              <a href="/en-US/docs/Web/HTTP/Methods/DELETE">DELETE</a>
            </code>
          </dt>
          <dd>
            <code>DELETE</code> удаляет указанный ресурс.
          </dd>
          <dt>
            <code>
              <a href="/en-US/docs/Web/HTTP/Methods/CONNECT">CONNECT</a>
            </code>
          </dt>
          <dd>
            <p>
              <code>CONNECT</code> устанавливает "туннель" к серверу,
              определённому по ресурсу.
            </p>
          </dd>
          <dt>
            <code>
              <a href="/ru/docs/Web/HTTP/Methods/OPTIONS">OPTIONS</a>
            </code>
          </dt>
          <dd>
            <code>OPTIONS</code> используется для описания параметров соединения
            с ресурсом.
          </dd>
          <dt>
            <code>
              <a href="/en-US/docs/Web/HTTP/Methods/TRACE">TRACE</a>
            </code>
          </dt>
          <dd>
            <p>
              <code>TRACE</code> выполняет вызов возвращаемого тестового
              сообщения с ресурса.
            </p>
          </dd>
          <dt>
            <code>
              <a href="/en-US/docs/Web/HTTP/Methods/PATCH">PATCH</a>
            </code>
          </dt>
          <dd>
            <code>PATCH</code> используется для частичного изменения ресурса.
          </dd>
        </dl>
    )`,
  },
  {
    id: 2,
    title: 'Какие версии HTTP-протокола вам известны?',
    category: [QuizletQuestionCategoryEnum.common],
    level: 1,
    links: [
      {
        label: 'Протоколы',
        href: 'https://developer.mozilla.org/ru/docs/Web/HTTP/Overview',
      },
      {
        label: 'Версии протоколов',
        href: 'https://zametkinapolyah.ru/servera-i-protokoly/standarty-http-protokola-istoriya-razvitiya-http-protokola-versii-http-protokola.html',
      },
    ],
    answer: `
        <p> Версий было много, но самые известные:</p>
        <p> Стандарт HTTP/0.9</p>
        <p> Стандарт HTTP/1.0</p>
        <p> Стандарт HTTP/1.1</p>
        <p> Стандарт HTTP/2.0</p>
      `,
  },
  {
    id: 3,
    title: 'Какие бывают коды ответа (состояния) HTTP?',
    category: [QuizletQuestionCategoryEnum.common],
    level: 1,
    links: [
      {
        label: 'Коды ответа',
        href: 'https://developer.mozilla.org/ru/docs/Web/HTTP/Status',
      },
    ],
    answer: ` 
      <ol>
        <li>Информационные 100 - 199</li>
        <li>Успешные 200 - 299</li>
        <li>Перенаправления 300 - 399</li>
        <li>Клиентские ошибки 400 - 499</li>
        <li>Серверные ошибки 500 - 599</li>
      </ol>
    `,
  },
  {
    id: 4,
    title: 'Что такое Cross-Origin Resource Sharing (CORS)?',
    category: [QuizletQuestionCategoryEnum.common],
    level: 1,
    links: [
      {
        label: 'CORS',
        href: 'https://developer.mozilla.org/ru/docs/Web/HTTP/CORS',
      },
      {
        label: 'Решение проблем с CORS',
        href: 'https://habr.com/ru/company/macloud/blog/553826/',
      },
    ],
    answer: `
        <p>
          <b>Cross-Origin Resource Sharing (CORS)</b> — механизм, использующий
          дополнительные HTTP-заголовки, чтобы дать возможность агенту
          пользователя (например, браузеру) получать разрешения на доступ к
          выбранным ресурсам с сервера на источнике (домене), отличном от того,
          что сайт использует в данный момент.
        </p>

        <p>
          Пример cross-origin запроса: HTML страница, обслуживаемая сервером с
          http://domain-a.com, запрашивает img src по адресу
          http://domain-b.com/image.jpg.
        </p>

        <p>
          В целях безопасности браузеры ограничивают cross-origin запросы,
          инициируемые скриптами. Например, XMLHttpRequest и Fetch API следуют
          политике одного источника (same-origin policy). Это значит, что
          web-приложения, использующие такие API, могут запрашивать HTTP-ресурсы
          только с того домена, с которого были загружены, пока не будут
          использованы CORS-заголовки.
        </p>

        <p>
          Использование заголовков Origin header и Access-Control-Allow-Origin
          показывает протокол контроля доступа в простейшем виде. В этом случае,
          сервер отвечает с Access-Control-Allow-Origin: * что означает, что к
          ресурсу может получить доступ с любого домена кросс-сайтовым способом.
          Если владелец ресурса http://bar.other пожелал ограничить доступ к
          ресурсу для запросов только с http://foo.example, они отправят
          обратно: Access-Control-Allow-Origin: http://foo.example
        </p>
      `,
  },
  {
    id: 5,
    title: 'Что такое cookie?',
    category: [QuizletQuestionCategoryEnum.common],
    level: 1,
    links: [{ label: 'Ссылка 1', href: 'https://learn.javascript.ru/cookie' }],
    answer: `
        <p>
          <b> Cookies</b> — это небольшие строки данных, которые хранятся
          непосредственно в браузере. Они являются частью HTTP-протокола
        </p>
        <p>
          Куки обычно устанавливаются веб-сервером при помощи заголовка
          Set-Cookie. Затем браузер будет автоматически добавлять их в (почти)
          каждый запрос на тот же домен при помощи заголовка Cookie.
          <p>
            Один из наиболее частых случаев использования куки – это
            аутентификация: При входе на сайт сервер отсылает в ответ
            HTTP-заголовок Set-Cookie для того, чтобы установить куки со
            специальным уникальным идентификатором сессии («session
            identifier»). Во время следующего запроса к этому же домену браузер
            посылает на сервер HTTP-заголовок Cookie. Таким образом, сервер
            понимает, кто сделал запрос. Мы также можем получить доступ к куки
            непосредственно из браузера, используя свойство document.cookie.
          </p>
        </p>
      `,
  },
  {
    id: 6,
    title: 'Какие ограничения есть у cookie?',
    category: [QuizletQuestionCategoryEnum.common],
    level: 1,
    links: [{ label: 'Ссылка 1', href: 'https://learn.javascript.ru/cookie' }],
    answer: `
        <ul>
          <li>
            Пара name=value не должна занимать более 4Кб. Таким образом, мы не
            можем хранить в куки большие данные.
          </li>
          <li>
            Общее количество куки на один домен ограничивается примерно 20+.
            Точное ограничение зависит от конкретного браузера.
          </li>
        </ul>
      `,
  },
  {
    id: 7,
    title: 'Что означает "use strict"?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    links: [
      {
        label: 'MDN',
        href: 'https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Strict_mode',
      },
      {
        label: 'LearnJS',
        href: 'https://learn.javascript.ru/strict-mode',
      },
    ],
    answer: `
        <p>
          <b> Strict mode</b> - позволяет использовать современный джаваскрипт
          (его более строгую версию)
        </p>
        <p>
          Строгий режим применяется ко всему скрипту или к отдельным функциям.
          Для этого в самом верху нужно прописать <i>"use strict"</i> или
          <i>'use strict'</i>. Переключить строгий режим нельзя. Все дальнейшее
          как в файле так и в функции (даже если есть вложенность) будет в
          строгом режиме
        </p>
        <p>
          Строгий режим принёс ряд изменений в обычную семантику JavaScript.
          <ol>
            <li>
              Cтрогий режим заменяет исключениями некоторые ошибки, которые
              интерпретатор JavaScript ранее молча пропускал
            </li>
            <li>
              Cтрогий режим исправляет ошибки, которые мешали движкам JavaScript
              выполнять оптимизацию -- в некоторых случаях код в строгом режиме
              может быть оптимизирован для более быстрого выполнения, чем код в
              обычном режиме.
            </li>
            <li>
              Cтрогий режим запрещает использовать некоторые элементы
              синтаксиса, которые, вероятно, в следующих версиях ECMAScript
              получат особый смысл.
            </li>
          </ol>
        </p>
      `,
  },

  {
    id: 8,
    title: 'Чем JS отличается при работе на front-end и back-end?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    answer: `
        <p>
          На фронтенде мы работаем с интерфейсом браузера либо инерпритатором
          его. В основном JS тут является декоративным элементом, не работающим
          с большими объемами данных и служит для улучшения качества работы
          пользователя. Фронтенд не имеет доступа к файлам и системе
          пользователя
        </p>
        <p>
          На бекенде мы не работает с декоративными элементами, а создаем
          интерфейс взаимодействия с базой данных, сохранением, добавлением,
          редактированием и чтением данных. Мы также можем обрабатывать большое
          количество данных, делать большие расчеты и выдавать результат в
          ответе
        </p>
      `,
  },
  {
    id: 9,
    title: 'Что такое статическая и динамическая типизация?',
    category: [QuizletQuestionCategoryEnum.common],
    level: 1,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://senior.ua/articles/kak-ponyat-raznicu-mezhdu-staticheskoy-i-dinamicheskoy-tipizaciey',
      },
    ],
    answer: `
        <p>
          <b> Статическая типизация </b>- это если тип переменной известен во
          время компиляции, а не выполнения. Типичными примерами таких языков
          являются Ada, C, C++, C#, JADE, Java, Fortran, Haskell, ML, Pascal, и
          Scala.
        </p>
        <p>
          <b>Динамическая типизация</b> — это когда процесс подтверждения
          типобезопасности программы во время её выполнения. Типичными примерами
          динамически типизированных языков являются Groovy, <u>JavaScript</u>,
          Lisp, Lua, Objective-C, PHP, Prolog, Python, Ruby, Smalltalk и Tcl.
        </p>
        <p>
          <b>Объявление типа</b>
        </p>
        <p>
          <i>Статическая проверка:</i> Все типы переменных должны быть явно
          указаны, так как эта информация требуется во время компиляции.
          Например в Java: float f = 0.5;
        </p>
        <p>
          <i>Динамическая проверка:</i> явное объявление не требуется, так как
          тип присваивается переменной во время выполнения. Например в Python: f
          = 0.5
        </p>
        <p>
          <b>Производительность</b>
        </p>
        <p>
          <i>Статическая проверка:</i> дополнительная обработка во время
          компиляции, но более высокая производительность во время выполнения.
        </p>
        <p>
          <i>Динамическая проверка:</i> более эффективные
          компиляторы/интерпретаторы, но проверка типов во время выполнения
          влияет на производительность.
        </p>
        <p>
          <b>Гибкость</b>
        </p>
        <p>
          <i>Статическая проверка:</i> менее подвержена ошибкам во время
          выполнения, но обеспечивает меньшую гибкость для программиста.
        </p>
        <p>
          <i>Динамическая проверка:</i> обеспечивает большую гибкость, но более
          подвержена ошибкам во время выполнения.
        </p>
        <p>
          <b>Сильно типизированный язык</b> — это такой язык, в котором
          переменные привязаны к конкретным типам данных, и который выдаст
          ошибку типизации в случае несовпадения ожидаемого и фактического типов
          — когда бы не проводилась проверка. Проще всего представить сильно
          типизированный язык как язык с высокой типобезопасностью. Например,
          сильно типизированный язык выдаст явную ошибку типизации, которая
          прервёт выполнение программы.
        </p>
        <p>
          Тем не менее, Ruby, Python и JavaScript (все они обладaют динамической
          типизацией) также являются сильно типизированными, хотя разработчику и
          не нужно указывать тип переменной при объявлении.
        </p>
        <p>
          <b>Слабо типизированный язык</b> — это язык, в котором переменные не
          привязаны к конкретному типу данных; у них всё ещё есть тип, но
          ограничения типобезопасности гораздо слабее.
        </p>
      `,
  },
  {
    id: 10,
    title: 'Как клиент взаимодействует с сервером?',
    category: [QuizletQuestionCategoryEnum.common],
    level: 1,
    links: [
      {
        label: 'Википедия',
        href: 'https://ru.wikipedia.org/wiki/%D0%9A%D0%BB%D0%B8%D0%B5%D0%BD%D1%82_%E2%80%94_%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80#:~:text=%D0%92%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D0%B5%20%D0%BA%D0%BB%D0%B8%D0%B5%D0%BD%D1%82%D0%B0%20%D0%B8%20%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D0%B0,-%D0%92%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%20%D0%B3%D0%BE%D0%B2%D0%BE%D1%80%D1%8F%2C%20%D1%81%D0%BB%D1%83%D0%B6%D0%B1%D0%B0&text=%D0%9A%D0%BB%D0%B8%D0%B5%D0%BD%D1%82%20%D0%BE%D1%82%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D1%8F%D0%B5%D1%82%20%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%2C%20%D0%B0%20%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80,%D0%B8%20%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%20%D0%B7%D0%BD%D0%B0%D0%BB%D0%B8%2C%20%D1%87%D0%B5%D0%B3%D0%BE%20%D0%BE%D0%B6%D0%B8%D0%B4%D0%B0%D1%82%D1%8C.',
      },
    ],
    answer: `
        <p>
          Клиенты и серверы обмениваются сообщениями в шаблоне запрос-ответ.
          Клиент отправляет запрос, а сервер возвращает ответ. Этот обмен
          сообщениями является примером межпроцессного взаимодействия. Для
          взаимодействия компьютеры должны иметь общий язык, и они должны
          следовать правилам, чтобы и клиент, и сервер знали, чего ожидать. Язык
          и правила общения определены в протоколе связи. Все протоколы
          клиент-серверной модели работают на уровне приложений. Протокол
          прикладного уровня определяет основные шаблоны диалога. Чтобы ещё
          больше формализовать обмен данными, сервер может реализовать интерфейс
          прикладного программирования (API). API — это уровень абстракции для
          доступа к сервису. Ограничивая связь определённым форматом контента,
          он облегчает синтаксический анализ. Абстрагируя доступ, он облегчает
          межплатформенный обмен данными.
        </p>
        <p>
          Сервер может получать запросы от множества различных клиентов за
          короткий период времени. Компьютер может выполнять только ограниченное
          количество задач в любой момент и полагается на систему планирования
          для определения приоритетов входящих запросов от клиентов для их
          удовлетворения. Чтобы предотвратить злоупотребления и максимизировать
          доступность серверное программное обеспечение может ограничивать
          доступность для клиентов. Атаки типа «отказ в обслуживании» используют
          обязанности сервера обрабатывать запросы, такие атаки действуют путем
          перегрузки сервера чрезмерной частотой запросов. Шифрование следует
          применять, если между клиентом и сервером должна передаваться
          конфиденциальная информация.
        </p>
      `,
  },
  {
    id: 11,
    title: 'Что такое REST?',
    category: [QuizletQuestionCategoryEnum.common],
    level: 1,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://systems.education/what-is-rest',
      },
      {
        label: 'Ссылка 2 (медиум)',
        href: 'https://medium.com/@andr.ivas12/rest-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D1%8B%D0%BC-%D1%8F%D0%B7%D1%8B%D0%BA%D0%BE%D0%BC-90a0bca0bc78',
      },
      {
        label: 'Youtube',
        href: 'https://www.youtube.com/watch?v=we4NVJtY_4E',
      },
    ],
    answer: `
        <p>
          REST (REpresentational State Transfer — «передача репрезентативного
          состояния» или «передача „самоописываемого“ состояния») — это стиль
          архитектуры
        </p>
        <p>Есть еще стиль SOAP.</p>
        <p>
          REST может использовать любые протоколы, а также любые форматы данных
          (XML, JSON)
        </p>
        <p>
          Специфика REST — использование HTTP в качестве транспортного
          протокола. Он подразумевает наилучшее использование функций,
          предоставляемых HTTP — методы запросов, заголовки запросов, ответы,
          заголовки ответов и т. д.
        </p>
        <p>Принципы:</p>
        <ol>
          <li>
            <strong>Независимость от состояния</strong> - не использовать
            сессии. Все необходимое сервер должен получать от клиента (токен
            акторизации, и другие необходимые параметры для выполнения запроса)
          </li>
          <li>
            <strong>Многоуровневость</strong> - может быть любое количество
            абстрауций. Клиенту все равно, что происходит на сервере, даже если
            это вызов других сервисов
          </li>
          <li>
            <strong>Единый унифицированный интерфейс</strong> - это когда через
            URL мы показываем что мы хотим получить, указываю саму сущьность и,
            возможно, ее айди. Например: GET /videos и GET /videos/1. Ресурсы
            должны быть однозначно идентифицированы посредством одного
            URL-адреса и только с помощью базовых методов сетевого протокола
            (DELETE, PUT, GET, HTTP).
          </li>
          <li>
            <strong>Кешируемость</strong> - может быть использовано кеширование
            запросов, явно указанное, на определенное количество времени
          </li>
          <li>
            <strong>Клиент-сервер</strong> - Должно быть четкое разграничение
            между клиентом и сервером: пользовательский интерфейс и вопросы
            сбора запросов — на стороне клиента. доступ к данным, управление
            рабочей нагрузкой и безопасность — на стороне сервера.
          </li>
          <li>
            <strong>Запрос кода (необязательгл)</strong> - В большинстве случаев
            сервер отправляет обратно статические представления ресурсов в
            формате XML или JSON. Однако при необходимости серверы могут
            отправлять исполняемый код непосредственно клиенту.
          </li>
        </ol>
     `,
  },

  {
    id: 12,
    title: 'Что такое SOAP?',
    category: [QuizletQuestionCategoryEnum.common],
    level: 1,
    links: [
      {
        label: 'Youtube',
        href: 'https://www.youtube.com/watch?v=we4NVJtY_4E',
      },
    ],
    answer: `
        <p>
          SOAP (Simple Object Access Protocol) - протокол обмена
          структурированными сообщениями
        </p>
        <p>Есть еще стиль REST.</p>
        <p>Формат данных - XML</p>
        <p>
          SOAP может использоваться с любым протоколом прикладного уровня: SMTP,
          FTP, HTTP, HTTPS и др. Однако его взаимодействие с каждым из этих
          протоколов имеет свои особенности, которые должны быть определены
          отдельно. Чаще всего SOAP используется поверх HTTP.
        </p>
        <p>
          Специфика SOAP — это формат обмена данными. С SOAP это всегда
          SOAP-XML, который представляет собой XML, включающий: — Envelope
          (конверт) – корневой элемент, который определяет сообщение и
          пространство имен, использованное в документе, — Header (заголовок) –
          содержит атрибуты сообщения, например: информация о безопасности или о
          сетевой маршрутизации, — Body (тело) – содержит сообщение, которым
          обмениваются приложения, — Fault – необязательный элемент, который
          предоставляет информацию об ошибках, которые произошли при обработке
          сообщений. И запрос, и ответ должны соответствовать структуре SOAP.
        </p>
        <p>Структура:</p>
        <ol>
          <li>
            <strong>Envelope</strong> — корневой элемент, который определяет
            сообщение и пространство имен, использованное в документе.
          </li>
          <li>
            <strong>Header</strong> — содержит атрибуты сообщения, например:
            информация о безопасности или о сетевой маршрутизации.
          </li>
          <li>
            <strong>Body</strong> — содержит сообщение, которым обмениваются
            приложения.
          </li>
          <li>
            <strong>Fault</strong> — необязательный элемент, который
            предоставляет информацию об ошибках, которые произошли при обработке
            сообщений.
          </li>
        </ol>
     `,
  },

  {
    id: 13,
    title: 'Что такое мутабельность и иммутабельность?',
    category: [QuizletQuestionCategoryEnum.common],
    level: 1,
    answer: `
        <p>
          Мутабельность - то что можно мутировать. Иммутабельность - то что
          нельзя мутировать.
        </p>
        <p>
          Все примитивы в JavaScript являются иммутабельными. Присваивая новое
          значение мы полностью переписываем его
        </p>
        <p>
          Объекты в JavaScript являются мутабельными. Объекты хранят лишь ссылку
          на данные, поэтому перезаписать свойство можно из любого объекта,
          имеющего ссылку на него
        </p>
      `,
  },

  {
    id: 14,
    title: 'Типы данных в JavaScript',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    answer: `
        <p>Есть 8 основных типов данных в JavaScript.</p>
        <ol>
          <li>
            <strong>String</strong>- typeof instance === "string", примитив
          </li>
          <li>
            <strong>Number</strong> - typeof instance === "number", примитив
          </li>
          <li>
            <strong>BigInt</strong> - typeof instance === "bigint", примитив
          </li>
          <li>
            <strong>Boolean</strong> - typeof instance === "boolean", примитив
          </li>
          <li>
            <strong>Null</strong> - typeof instance === "object", НЕ примитив
          </li>
          <li>
            <strong>Undefined</strong> - typeof instance === "undefined",
            примитив
          </li>
          <li>
            <strong>Symbol</strong> - typeof instance === "symbol", примитив
          </li>
          <li>
            <strong>Object</strong> - typeof instance === "object", НЕ примитив
          </li>
          <li>
            <strong>Record</strong> - typeof instance === "record", примитив
          </li>
          <li>
            <strong>Tuple</strong> - typeof instance === "tuple", примитив
          </li>
        </ol>

        <p>
          Из них, 8 типов являются примитивами: string, number, bigInt, boolean,
          undefined, symbol, tuple, record
        </p>
     `,
  },

  {
    id: 15,
    title: 'Как проверить, является ли объект массивом',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    answer: `
        <code>Array.isArray(obj)</code>
    `,
  },

  {
    id: 16,
    title: 'Как проверить, является ли число целым',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    answer: `
        <code>isInteger(myNum)</code>
    `,
  },

  {
    id: 17,
    title: 'Как проверить, является ли переменная NaN?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    answer: `
        <p>
          <code>
            NaN == NaN // false
            <br />
            NaN === NaN // false
            <br />
            isNaN(NaN); // true
            <br />
            Number.isNaN(NaN); // true
          </code>
        </p>
        <p>
          Тем не менее, обратите внимание на разницу между функцией isNaN() и
          методом Number.isNaN(): первая вернёт true, если значение в настоящий
          момент является NaN, или если оно станет NaN после того, как
          преобразуется в число, в то время как последний вернёт true, только
          если текущим значением является NaN:
        </p>
        <p>
          <code>
            isNaN('hello world'); // true <br />
            Number.isNaN('hello world'); // false
          </code>
        </p>
     `,
  },

  {
    id: 18,
    title: 'Чем отличается isNaN() и Number.isNaN()?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    answer: `
        <p>
          isNaN() вернёт true, если значение в настоящий момент является NaN,
          или если оно станет NaN после того, как преобразуется в число, в то
          время как Number.isNaN() вернёт true, только если текущим значением
          является NaN:
        </p>
        <p>
          <code>
            isNaN('hello world'); // true <br />
            Number.isNaN('hello world'); // false
          </code>
        </p>
     `,
  },

  {
    id: 19,
    title: 'Чем отличается var, let и const?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    answer: `
        <p>
          До стандарта ES-2015 существовал лишь один способ декларирования
          переменной - это var
        </p>
        <p>
          <strong>var</strong> - это простое декларирование переменное, с
          функциональной областью видимости. Значение внутри можно перезаписать,
          а обратиться к без ошибки можно будет в рамках функции либо файла
        </p>
        <p>
          <strong>let</strong> - это появившийся в ES-2015 способ декларирования
          переменной с блочной областью видимости. Значение внутри можно
          перезаписать, а обратиться к без ошибки можно будет в рамках блока
          (фигурных скобок) либо файла
        </p>
        <p>
          <strong>const</strong> - это появившийся в ES-2015 способ
          декларирования переменной с блочной областью видимости. Значение
          внутри нельзя перезаписать, а обратиться к без ошибки можно будет в
          рамках блока (фигурных скобок) либо файла
        </p>
     `,
  },

  {
    id: 20,
    title: 'Что такое область видимости (scope)?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://itchief.ru/javascript/scope-and-context',
      },
    ],
    answer: `
        <p>
          <strong>Область видимости</strong> – это некоторая сущность
          JavaScript, которая определяет границы действия переменных.
        </p>
        <p>
          Создаются области видимости во время выполнения программы. Самая
          первая область, которая создаётся и которая включает в себя все
          остальные называется <strong>глобальной</strong>.
        </p>
        <p>
          Именно в этой области определены такие переменные как window в
          веб-браузере и global в Node.js. Вы также можете определять переменные
          в этой области. Для этого достаточно просто объявить переменные вне
          блока, функции и модуля. В этом случае они будут находиться в
          глобальной области видимости
        </p>
        <p>
          Переменные объявленные в глобальной области видимости называются
          <strong>глобальными переменными</strong>. Такие переменные могут быть
          доступны в любой точке программы. Кроме глобальной области видимости в
          JavaScript имеются ещё <strong>локальные</strong>. Они, создаются,
          когда интерпретатор, например, выполняет код блочной конструкции,
          функциональной или модульной. Причем такая локальная область видимости
          называется областью видимости блока, функции или модуля.
        </p>
        <p>
          Всего существует 4 вида области видимости: глобальный, модульных,
          функциональный и блочный
        </p>
        <p>
          <strong>Цепочка областей видимости</strong>
        </p>
        <p>
          При создании локальной области видимости она всегда сохраняет ссылку
          на внешнюю область видимости. Эта ссылка используется для поиска
          переменных.
        </p>
        <p>
          Таким образом, цепочкой областей видимости (scope chain) можно назвать
          последовательность областей видимости, которые интерпретатор
          JavaScript использует для поиска переменных. При этом поиск всегда
          начинается с текущей области видимости и если только она не найдена в
          текущей, то происходит переход к следующей по цепочке и поиск
          переменной там и т.д.
        </p>
        <p>
          Итак, поиск переменной интерпретатор JavaScript всегда начинает с
          текущей области видимости. Если она в ней имеется, то поиск
          прекращается и берётся эта переменная. В противном случае
          интерпретатор в поиске переменной переместится к следующей области,
          содержащейся в ссылке, и попробует отыскать её там. После этого
          действия повторяются, т.е. при отсутствии искомой переменной в
          просматриваемой области видимости, интерпретатор перемещается к
          следующей области посредством ссылки и пытается обнаружить её там.
        </p>
        <p>
          Глобальная область видимости - это последнее звено в цепочке областей
          видимости Она не содержит ссылку на другую область, на ней всё
          заканчивается.
        </p>
      `,
  },

  {
    id: 21,
    title: 'Что такое контекст?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://itchief.ru/javascript/scope-and-context',
      },
    ],
    answer: `
        <p>
          Кроме области видимости в JavaScript имеется ещё контекст (context).
        </p>
        <p>
          <strong>Контекст</strong> – это то, на что указывает this. По сути
          this – это объект, которому «принадлежит» выполняемый в данный момент
          код.
        </p>
        <ol>
          <li>
            В контексте глобального объекта (вне модулей и функций) this – это
            глобальный объект.
          </li>
          <li>
            Внутри функции this зависит от того, как вызывается функция.
            <ol>
              <li>
                Если функция вызывается не как метод объекта, то this в не
                строгом режиме указывает на глобальный объект, а в строгом –
                undefined.
              </li>
              <li>
                Когда функция вызывается как метод, this – это объект, который
                использовался для его вызова:
              </li>
            </ol>
          </li>
          <li>
            Внутри класса this указывает на новый объект, который будет создан с
            помощью new
          </li>
          <li>В модуле на верхнем уровне this – это undefined</li>
        </ol>
        <p>
          Стрелочные функции нет имеют собственного this. Если внутри стрелочной
          функции происходит обращение к this, она берёт его снаружи.
        </p>
     `,
  },

  {
    id: 22,
    title: 'Чем отличается контекст от области вызова (scope)?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    answer: `
        <p>Контекст - это то на что указывает this объект.</p>
        <p>
          Область видимости - это доступ до переменных от текущего до самого
          глобального.
        </p>
        <p>
          Область видимости относится к видимости переменных, а контекст
          относится к к объекту this, внутри которого выполняется функция.
        </p>
      `,
  },

  {
    id: 23,
    title: 'Что такое деструктуризация?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    links: [
      {
        label: 'Learn Javascript',
        href: 'https://learn.javascript.ru/destructuring-assignment',
      },
    ],
    answer: `
        <p>
          <strong>Деструктуризация (destructuring assignment)</strong> – это
          специальный синтаксис, который позволяет нам «распаковать» массивы или
          объекты в кучу переменных, так как иногда они более удобны.
          Деструктуризация также прекрасно работает со сложными функциями,
          которые имеют много параметров, значений по умолчанию и так далее.
        </p>
        <br />
        <br />

        <p>
          <strong>Деструктуризация массива</strong>
        </p>
        <p>либо другого перебираемого объекта, например Set, string</p>
        <p>
          <code>
            let arr = ["Ilya", "Kantor", 50] <br />
            <br />
            let [firstName, surname] = arr;
            <br />
            <br />
            let [,,age] = arr; // можно пропускать элементы через запятую
            <br />
            <br />
            let user = {};<br />
            [user.name, user.surname] = arr; // можно записать даже объект сразу
            <br />
            <br />
            let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the
            Roman Republic"]; // остаточные элементы массива запишутся в rest
            <br />
            <br />
            let [name = "Guest", surname = "Anonymous"] = ["Julius"]; //
            значения по умолчанию
          </code>
        </p>
        <p>
          Если при деструктуразации не будет нужного индекса массива, то в
          переменную запишется undefined
        </p>
        <br />
        <br />

        <p>
          <strong>Деструктуризация объекта</strong>
        </p>
        <p>
          <code>
            let options = {
              title: "Menu",
              width: 100,
              height: 200
            };<br/>
            let {title, width, height} = options; // обычное присваивание, переменные называются аналогично параметрам <br/>
            let {width: w, height: h, title} = options; // присваивание со своими собственными переменными (справа)<br/>
            let {width = 100, height = 200, title} = options; // присвоение со значением по умаолчанию (если параметр отсутствует) <br/>
            let {title, ...rest} = options; // остаточные параметры запишутся в rest объект
          </code>
        </p>
        <br />
        <br />
        <p>Про вложенную деструктуризацию и как засунуть эту деструктуризацию в функции по умному читай по ссылкам</p>
     `,
  },

  {
    id: 24,
    title: 'Для чего предназначены методы setTimeout и setInterval?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    links: [
      {
        label: 'Learn Javascript',
        href: 'https://learn.javascript.ru/settimeout-setinterval',
      },
    ],
    answer: `
      <p>Эти методы предназначены для планирования</p>

      <p>Мы можем вызвать функцию не в данный момент, а позже, через заданный интервал времени. Это называется «планирование вызова».</p>

      <p>Для этого существуют два метода:</p>

      <ol>
        <li><strong>setTimeout</strong> позволяет вызвать функцию один раз через определённый интервал времени.</li>
        <li><strong>setInterval</strong> позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени.</li>
      </ol>
      
      <p>Эти методы не являются частью спецификации JavaScript. Но большинство сред выполнения JS-кода имеют внутренний планировщик и предоставляют доступ к этим методам. В частности, они поддерживаются во всех браузерах и Node.js.</p>
      
      <code>
        let timerId = setTimeout(func, [delay], [arg1], [arg2], ...) <br/>
        let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...)
      </code>
    `,
  },

  {
    id: 25,
    title: 'Чем отличаются callbacks, promises и async/await?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    answer: `
      <p>Callbacks, promises и async/await - это способ выполнения одного кода после выполнения другого, подождав его завершения</p>

      <p><strong>Callback</strong> -  это дословно «функция обратного вызова». Это значит, что callback — это функция, которую мы передаем в другую функцию в качестве параметра для последующего выполнения</p>
    
      <p><strong>Promises</strong> - Промисы — новый стиль написания асинхронного кода, который используется в современных Web API</p>
    
      <p>Промис — это объект, представляющий асинхронную операцию, выполненную удачно или неудачно. Он представляет собой как бы промежуточное состояние. По сути, это способ браузера сказать: "я обещаю вернуться к вам с ответом как можно скорее", поэтому в дословном переводе "промис" (promise) означает "обещание".</p>
      
      <p>У промиса есть три основных блока: then, catch и finally</p>

      <p><strong>Async/await</strong> - На самом деле это расширенный интерфейс работы с промисами. Но код с использованием этого подхода иногда получается более приятным. Главную функцию нужно обернуть в async, а далее все асинхронные функции внутри могут использовать await, чтобы код дождался их выполнения</p>
      `,
  },

  {
    id: 26,
    title: 'Можно ли записывать новые функции в прототипы стандартных классов?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    links: [
      {
        label: 'Learn Javascript',
        href: 'https://learn.javascript.ru/native-prototypes',
      },
    ],
    answer: `
      <p>Встроенные прототипы <strong>можно изменять</strong>. Например, если добавить метод к String.prototype, метод становится доступен для всех строк</p>
      
      <code>
        String.prototype.show = function() { <br/>
          alert(this);<br/>
        };<br/>
        <br/>
        "BOOM!".show(); // BOOM!
      </code>

      <p>В течение процесса разработки у нас могут возникнуть идеи о новых встроенных методах, которые нам хотелось бы иметь, и искушение добавить их во встроенные прототипы. <strong>Это плохая идея</strong></p>

      <p>Прототипы глобальны, поэтому очень легко могут возникнуть конфликты. Если две библиотеки добавляют метод String.prototype.show, то одна из них перепишет метод другой.
      Так что, в общем, изменение встроенных прототипов считается плохой идеей.</p>

      <p>В современном программировании есть только один случай, в котором одобряется изменение встроенных прототипов. Это создание полифилов.</p>

      <p><strong>Полифил</strong> – это термин, который означает эмуляцию метода, который существует в спецификации JavaScript, но ещё не поддерживается текущим движком JavaScript.</p>
     `,
  },

  {
    id: 27,
    title: 'Методы массивов',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    links: [
      {
        label: 'Learn Javascript',
        href: 'https://learn.javascript.ru/array-methods',
      },
    ],
    answer: `
      <p><strong>Добавление/удаление элементов</strong></p>
      
      <ol>
        <li><code>arr.push(...items)</code> – добавляет элементы в конец</li>
        <li><code>arr.pop()</code> – извлекает элемент из конца</li>
        <li><code>arr.shift()</code> – извлекает элемент из начала</li>
        <li><code>arr.unshift(...items)</code> – добавляет элементы в начало</li>
        <li><code>arr.splice(index[, deleteCount, elem1, ..., elemN])</code> – Он начинает с позиции index, удаляет deleteCount элементов и вставляет elem1, ..., elemN на их место. Возвращает массив из удалённых элементов</li>
        <li><code>arr.slice([start], [end])</code> - возвращает новый массив, в который копирует элементы, начиная с индекса start и до end (не включая end). Оба индекса start и end могут быть отрицательными. В таком случае отсчёт будет осуществляться с конца массива</li>
        <li><code>arr.concat(arg1, arg2...)</code> - создаёт новый массив, в который копирует данные из других массивов и дополнительные значения arg добавляет. Если аргумент argN – массив, то все его элементы копируются. Иначе скопируется сам аргумент.</li>
      </ol>

      <p><strong>Поиск в массиве</strong></p>
      <ol>
        <li><code>arr.indexOf(item, from)</code> - ищет item, начиная с индекса from, и возвращает индекс, на котором был найден искомый элемент, в противном случае -1</li>
        <li><code>arr.lastIndexOf(item, from)</code> – то же самое, но ищет справа налево.</li>
        <li><code>arr.includes(item, from)</code> – ищет item, начиная с индекса from, и возвращает true, если поиск успешен.</li>
        <li><code>arr.find(func)</code> - поиск первого совпавшего элемента</li>
        <li><code>arr.findIndex(func)</code> – по сути, то же самое, но возвращает индекс, на котором был найден элемент, а не сам элемент, и -1, если ничего не найдено</li>
        <li><code>arr.filter(func)</code> - Синтаксис этого метода схож с find, но filter возвращает массив из всех подходящих элементов</li>
       </ol>

      <p><strong>Перебор</strong></p>
      <ol>
        <li><code>arr.forEach(func)</code> -  позволяет запускать функцию для каждого элемента массива</li>
      </ol>

      <p><strong>Перебор и преобразование массива</strong></p>
      <ol>
        <li><code>arr.map(func)</code> - Он вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции</li>
        <li><code>arr.sort()</code> - сортирует массив на месте, меняя в нём порядок элементов</li>
        <li><code>arr.reverse()</code> - меняет порядок элементов в arr на обратный.</li>
        <li><code>arr.join(glue)</code> - делает в точности противоположное split. Он создаёт строку из элементов arr, вставляя glue между ними</li>
        <li><code>arr.reduce(function(previousValue, item, index, array)</code> - используется для вычисления какого-нибудь единого значения на основе всего массива</li>
        <li><code>arr.reduceRight(function(previousValue, item, index, array)</code> - используется для вычисления какого-нибудь единого значения на основе всего массива, но проходит по массиву справа налево</li>
      </ol>

      <p><strong>Helpers</strong></p>
      <ol>
        <li><code>Array.isArray(someVar)</code> - проверка на то, является ли переменная массивом</li>
      </ol>

      <p>Почти все методы массива, которые вызывают функции – такие как find, filter, map, за исключением метода sort, принимают необязательный параметр thisArg. Значение параметра thisArg становится this для func</p>
    `,
  },

  {
    id: 28,
    title: 'Какие перебирающие способы массива знаете?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    links: [
      {
        label: 'Learn Javascript',
        href: 'https://learn.javascript.ru/array-methods',
      },
    ],
    answer: `
      <p><strong>Перебор</strong></p>
      <ol>
        <li><code>arr.forEach(func)</code> -  позволяет запускать функцию для каждого элемента массива</li>
      </ol>

      <p><strong>Перебор и преобразование массива</strong></p>
      <ol>
        <li><code>arr.map(func)</code> - Он вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции</li>
        <li><code>arr.sort()</code> - сортирует массив на месте, меняя в нём порядок элементов</li>
        <li><code>arr.reverse()</code> - меняет порядок элементов в arr на обратный.</li>
        <li><code>arr.join(glue)</code> - делает в точности противоположное split. Он создаёт строку из элементов arr, вставляя glue между ними</li>
        <li><code>arr.reduce(function(previousValue, item, index, array)</code> - используется для вычисления какого-нибудь единого значения на основе всего массива</li>
        <li><code>arr.reduceRight(function(previousValue, item, index, array)</code> - используется для вычисления какого-нибудь единого значения на основе всего массива, но проходит по массиву справа налево</li>
      </ol>

      <p>Почти все методы массива, которые вызывают функции – такие как find, filter, map, за исключением метода sort, принимают необязательный параметр thisArg. Значение параметра thisArg становится this для func</p>
    `,
  },

  {
    id: 29,
    title: 'Какие бывают операторы в Javascript?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    links: [
      {
        label: 'MDN',
        href: 'https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Expressions_and_Operators',
      },
    ],
    answer: `
      <ul>
        <li>Операторы присваивания</li>
        <li>Операторы сравнения</li>
        <li>Арифметические операторы</li>
        <li>Битовые (поразрядные) операторы</li>
        <li>Логические операторы</li>
        <li>Строковые операторы</li>
        <li>Условный (тернарный) оператор</li>
        <li>Оператор запятая</li>
        <li>Унарные операторы</li>
        <li>Операторы отношения</li>
        <li>Приоритет операторов</li>
      </ul>
    `,
  },

  {
    id: 30,
    title: 'Операторы присваивания',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    links: [
      {
        label: 'MDN',
        href: 'https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Expressions_and_Operators',
      },
    ],
    answer: `
      <p>В результате операции присваивания операнду слева от оператора присваивания (знак "=") устанавливается значение , которое берётся из правого операнда. Основным оператором присваивания является  =, он присваивает значение правого операнда операнду, находящемуся слева. Таким образом, выражение x = y означает, что x присваивается значение y.</p>

      <p>Существуют также составные операторы присваивания, которые используются для сокращённого представления операций, описанных в следующей таблице:</p>

      <table class="standard-table">
        <caption>Список операторов присваивания</caption>
        <tbody>
          <tr>
          <th>Имя</th>
          <th>Сокращённый оператор</th>
          <th>Обычный оператор</th>
          <th>Описание</th>
          </tr>
          <tr>
          <td>Присваивание</td>
          <td><code>x = y</code></td>
          <td><code>x = y</code></td>
          <td></td>
          </tr>
          <tr>
          <td>Присваивание со сложением</td>
          <td><code>x += y</code></td>
          <td><code>x = x + y</code></td>
          <td></td>
          </tr>
          <tr>
          <td>Присваивание с вычитанием</td>
          <td><code>x -= y</code></td>
          <td><code>x = x - y</code></td>
          <td></td>
          </tr>
          <tr>
          <td>Присваивание с умножением</td>
          <td><code>x *= y</code></td>
          <td><code>x = x * y</code></td>
          <td></td>
          </tr>
          <tr>
          <td>Присваивание с делением</td>
          <td><code>x /= y</code></td>
          <td><code>x = x / y</code></td>
          <td></td>
          </tr>
          <tr>
          <td>Присваивание по модулю</td>
          <td><code>x&nbsp;%= y</code></td>
          <td><code>x = x&nbsp;% y</code></td>
          <td>Выявляет остаток от числа при делении x на y</td>
          </tr>
          <tr>
          <td>Присваивание с левым сдвигом</td>
          <td><code>x &lt;&lt;= y</code></td>
          <td><code>x = x &lt;&lt; y</code></td>
          <td>Берется битовое значение (нули и единицы) старого значения и сдвигается влево на указанное колличество знаков.</td>
          </tr>
          <tr>
          <td>Присваивание с правым сдвигом</td>
          <td><code>x &gt;&gt;= y</code></td>
          <td><code>x = x &gt;&gt; y</code></td>
          <td>Берется битовое значение (нули и единицы) старого значения и сдвигается вправо на указанное колличество знаков.</td>
          </tr>
          <tr>
          <td>Присваивание с беззнаковым сдвигом вправо</td>
          <td><code>x &gt;&gt;&gt;= y</code></td>
          <td><code>x = x &gt;&gt;&gt; y</code></td>
          <td>Для неотрицательных чисел сдвиг вправо с заполнением нулями и сдвиг вправо с распространением знака дают одинаковый результат. Например, 9 >>> 2 дает 2, то же самое, что 9 >> 2. Однако это не относится к отрицательным числам. Например, -9 >>> 2 дает 1073741821, что отличается от -9 >> 2 (что дает -3 )</td>
          </tr>
          <tr>
          <td>Присваивание с побитовым AND</td>
          <td><code>x &amp;= y</code></td>
          <td><code>x = x &amp; y</code></td>
          <td>Результат a & b равен единице только когда оба бита a и b равны единице. ЭТО НЕ БУЛЕВОЕ, это именно побитовка</td>
          </tr>
          <tr>
          <td>Присваивание с побитовым XOR</td>
          <td><code>x ^= y</code></td>
          <td><code>x = x ^ y</code></td>
          <td>Выполняет операцию «Исключающее ИЛИ» над каждой парой бит.
          a Исключающее ИЛИ b равно 1, если только a=1 или только b=1, но не оба одновременно a=b=1</td>
          </tr>
          <tr>
          <td>Присваивание с побитовым OR</td>
          <td><code>x |= y</code></td>
          <td><code>x = x | y</code></td>
          <td>Выполняет операцию ИЛИ над каждой парой бит. Результат a | b равен 1, если хотя бы один бит из a,b равен 1.</td>
          </tr>
        </tbody>
        </table>

        <p>Еще оператором присваения модно считать деструктуризацию</p>
    `,
  },

  {
    id: 31,
    title: 'Операторы сравнения',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    links: [
      {
        label: 'MDN',
        href: 'https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Expressions_and_Operators',
      },
    ],
    answer: `
      <p>Сравнивает свои операнды и возвращает логическое значение, базируясь на истинности сравнения. Операнды могут быть числами, строками, логическими величинами или объектами.</p>
      
      <ul>
        <li>Равно (==)</li>
        <li>Не равно (!=)</li>
        <li>Строго равно (===)</li>
        <li>Строго не равно(!==)</li>
        <li>Больше (>)</li>
        <li>Больше или равно (>=)</li>
        <li>Меньше (<)</li>
        <li>Меньше или равно (<=)</li>
      </ul>
      `,
  },

  {
    id: 32,
    title: 'Арифметические операторы',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    links: [
      {
        label: 'MDN',
        href: 'https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Expressions_and_Operators',
      },
    ],
    answer: `
      <p>Используют в качестве своих операндов числа (также литералы или переменные) и в качестве результата возвращают одно числовое значение. Стандартными арифметическими операторами являются сложение (+), вычитание (-), умножение (*), и деление (/).</p>
      
      <ul>
        <li>Бинарное Сложение (+) x + y</li>
        <li>Бинарное Вычитание (-) x - y</li>
        <li>Бинарное Умножение (*) x * y</li>
        <li>Бинарное Деление(/) x / y</li>
        <li>Бинарный Остаток от деления (%) x % y</li>
        <li>Бинарное Возведение в степень (**) x ** y</li>
        <li>Унарный Инкремент (++) ++x</li>
        <li>Унарный Декремент (--) --x</li>
        <li>Унарный Плюс (+) +x</li>
        <li>Унарный Минус (-) -x</li>
      </ul>
      `,
  },

  {
    id: 33,
    title: 'Битовые (поразрядные) операторы',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    links: [
      {
        label: 'MDN',
        href: 'https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Expressions_and_Operators',
      },
    ],
    answer: `
      <p>Битовые операторы (en-US) обрабатывают свои операнды как последовательности из 32 бит (нулей и единиц), а не как десятичные, шестнадцатеричные или восьмеричные числа. Например, десятичное число 9 имеет двоичное представление 1001. Битовые операторы выполняют операции над таким двоичным представлением, но результат возвращают как обычное числовое значение JavaScript.</p>
      
      <table class="standard-table">
        <caption>Битовые операторы</caption>
        <thead>
          <tr>
          <th scope="col">Оператор</th>
          <th scope="col">Использование</th>
          <th scope="col">Описание</th>
          </tr>
        </thead>
        <tbody>
          <tr>
          <td>Побитовое И</td>
          <td><code>a &amp; b</code></td>
          <td>Возвращает единицу в каждой битовой позиции, для которой соответствующие биты обеих операндов являются единицами.</td>
          </tr>
          <tr>
          <td>Побитовое ИЛИ</td>
          <td><code>a | b</code></td>
          <td>Возвращает единицу в каждой битовой позиции, для которой один из соответствующих битов или оба бита операндов являются единицами.</td>
          </tr>
          <tr>
          <td>Исключающее ИЛИ</td>
          <td><code>a ^ b</code></td>
          <td>Возвращает единицу в каждой битовой позиции, для которой только один из соответствующих битов операндов является единицей.</td>
          </tr>
          <tr>
          <td>>Побитовое НЕ</td>
          <td><code>~ a</code></td>
          <td>Заменяет биты операнда на противоположные.</td>
          </tr>
          <tr>
          <td>Сдвиг влево</td>
          <td><code>a &lt;&lt; b</code></td>
          <td>Сдвигает&nbsp;<code>a</code> в двоичном представлении на&nbsp;<code>b</code> бит влево, добавляя справа нули.</td>
          </tr>
          <tr>
          <td>Сдвиг вправо с переносом знака</td>
          <td><code>a &gt;&gt; b</code></td>
          <td>Сдвигает&nbsp;<code>a</code> в двоичном представлении на <code>b</code> бит вправо, отбрасывая сдвигаемые биты.</td>
          </tr>
          <tr>
          <td>Сдвиг вправо с заполнением нулями</td>
          <td><code>a &gt;&gt;&gt; b</code></td>
          <td>Сдвигает&nbsp;<code>a</code> в двоичном представлении на <code>b</code> бит вправо, отбрасывая сдвигаемые биты&nbsp;и добавляя слева нули.</td>
          </tr>
        </tbody>
      </table>
      `,
  },

  {
    id: 34,
    title: 'Логические операторы',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    links: [
      {
        label: 'MDN',
        href: 'https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Expressions_and_Operators',
      },
    ],
    answer: `
      <p>Логические операторы (en-US) обычно используются с булевыми (логическими) значениями; при этом возвращаемое ими значение также является булевым. Однако операторы && и || фактически возвращают значение одного из операндов, поэтому, если эти операторы используются с небулевыми величинами, то возвращаемая ими величина также может быть не булевой.</p>
      
      <ul>
        <li>Логическое И (&&) x && y</li>
        <li>Логическое ИЛИ (||) x || y</li>
        <li>Логическое НЕ (!) !x</li>
      </ul>
      `,
  },

  {
    id: 35,
    title: 'Строковые операторы',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    links: [
      {
        label: 'MDN',
        href: 'https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Expressions_and_Operators',
      },
    ],
    answer: `
      <p>В дополнение к операторам сравнения, которые могут использоваться со строковыми значениями, оператор (+) позволяет объединить две строки, возвращая при этом третью строку, которая представляет собой объединение двух строк-операндов:</p>
      <p>console.log("my " + "string");  // в консоли выведется строка  "my string".</p>
      <p>Сокращённый оператор присваивания += также может быть использован для объединения (конкатенации) строк:</p>
      <p>var  mystring = "alpha";  mystring += "bet";.</p>
      `,
  },

  {
    id: 36,
    title: 'Условный (тернарный) оператор',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    links: [
      {
        label: 'MDN',
        href: 'https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Expressions_and_Operators',
      },
    ],
    answer: `
      <p>Условный оператор является единственным оператором JavaScript, который использует три операнда. Оператор принимает одно из двух значений в зависимости от заданного условия. Синтаксис оператора:</p>
      <p>condition ? val1 : val2</p>
      `,
  },

  {
    id: 37,
    title: 'Унарные операторы',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    links: [
      {
        label: 'MDN',
        href: 'https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Expressions_and_Operators',
      },
    ],
    answer: `
      <p>Унарная операция - операция только с одним операндом.</p>
      <ul>
        <li>
          <strong>delete</strong>
          Оператор delete выполняет удаление объекта, свойства объекта, или элемента массива с заданным индексом. Возвращает результат в виде boolean.
          <br/>
          <code>
          delete objectName;<br/>
          delete objectName.property; <br/>
          delete arr[index];
          </code>
        </li>

        <br/>

        <li>
          <strong>typeof</strong>
          Оператор typeof возвращает строку обозначающую тип невычисленного операнда. Значение operand может быть строкой, переменной, дескриптором, или объектом, тип которого следует определить. Скобки вокруг операнда необязательны.
          <br/>
          <code>
            typeof myFun;     // возвращает "function"<br/>
            typeof shape;     // возвращает "string"<br/>
            typeof size;      // возвращает "number"<br/>
            typeof today;     // возвращает "object"<br/>
            typeof dontExist; // возвращает "undefined"<br/>
            typeof true; // возвращает "boolean"<br/>
            typeof null; // возвращает "object"
          </code>
        </li>

        <br/>

        <li>
          <strong>void</strong>
          <br/>
          <code>
            void (expression)<br/>
            void expression
          </code>

          <br/>
          Оператор void определяет выражение, которое должно быть вычислено без возвращения результата. expression - это выражение JavaScript, требующее вычисления. Скобки вокруг выражения необязательны, но их использование является правилом хорошего тона.
          <br/>
          Вы можете использовать оператор void для указания на то, что операнд-выражение является гипертекстовой ссылкой. При этом выражение обрабатывается, но не загружается в текущий документ.
          <br/>
          Следующий код служит примером создания гипертекстовой ссылки, которая бездействует при нажатии на неё пользователем. Когда пользователь нажимает на ссылку, void(0) вычисляется равным undefined, что не приводит ни к каким действиям в JavaScript.
          <br/>
          <code>
            href="javascript:void(0)" // Нажмите здесь, чтобы ничего не произошло
          </code>
          <br/>
          Приведённый ниже код создаёт гипертекстовую ссылку, которая подтверждает отправку формы при клике на ней пользователем:
          <br/>
          <code>
            a href="javascript:void(document.form.submit())" // Нажмите здесь, чтобы подтвердить отправку формы
          </code>
        </li>
      </ul>
      `,
  },

  {
    id: 38,
    title: 'Операторы отношения',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    links: [
      {
        label: 'MDN',
        href: 'https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Expressions_and_Operators',
      },
    ],
    answer: `
    <p>Оператор отношения сравнивает свои операнды и возвращает результат сравнения в виде булева значения.</p>

    <ul>
      <li>
        <strong>in</strong>
        Оператор in возвращает true, если указанный объект имеет указанное свойство. Синтаксис оператора: <br/>
        <code>propNameOrNumber in objectName</code>
      </li>

      <br/>

      <li>
        <strong>instanceof</strong>
        Оператор instanceof возвращает true, если заданный объект является объектом указанного типа. Его синтаксис: <br/>

        <code>objectName instanceof objectType</code>

        где objectName - имя объекта, тип которого необходимо сравнить с objectType, а objectType - тип объекта, например, Date или Array.
      </li>

      <br/>

      <li>
        <strong>void</strong>
        <br/>
        <code>
          void (expression)<br/>
          void expression
        </code>

        <br/>
        Оператор void определяет выражение, которое должно быть вычислено без возвращения результата. expression - это выражение JavaScript, требующее вычисления. Скобки вокруг выражения необязательны, но их использование является правилом хорошего тона.
        <br/>
        Вы можете использовать оператор void для указания на то, что операнд-выражение является гипертекстовой ссылкой. При этом выражение обрабатывается, но не загружается в текущий документ.
        <br/>
        Следующий код служит примером создания гипертекстовой ссылки, которая бездействует при нажатии на неё пользователем. Когда пользователь нажимает на ссылку, void(0) вычисляется равным undefined, что не приводит ни к каким действиям в JavaScript.
        <br/>
        <code>
          href="javascript:void(0)" // Нажмите здесь, чтобы ничего не произошло
        </code>
        <br/>
        Приведённый ниже код создаёт гипертекстовую ссылку, которая подтверждает отправку формы при клике на ней пользователем:
        <br/>
        <code>
          a href="javascript:void(document.form.submit())" // Нажмите здесь, чтобы подтвердить отправку формы
        </code>
      </li>
    </ul>
    `,
  },

  {
    id: 39,
    title: 'Оператор запятая',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    links: [
      {
        label: 'MDN',
        href: 'https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Expressions_and_Operators',
      },
    ],
    answer: `
      <p>Оператор запятая (,) просто вычисляет оба операнда и возвращает значение последнего операнда. Данный оператор в основном используется внутри цикла for, что позволяет при каждом прохождении цикла одновременно обновлять значения нескольких переменных.</p>

      <p>Например, если a является двумерным массивом, каждая строка которого содержит 10 элементов, то следующий код с использованием оператора запятая позволяет выполнять одновременное приращение двух переменных. Данный код выводит на экран значения диагональных элементов массива:</p>
      
      <br/>

      <code>
        for (var i = 0, j = 9; i <= 9; i++, j--) <br/>
        document.writeln("a[" + i + "][" + j + "]= " + a[i][j]);
      </code>
    `,
  },

  {
    id: 40,
    title: 'Приоритет операторов',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    links: [
      {
        label: 'MDN',
        href: 'https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Expressions_and_Operators',
      },
    ],
    answer: `
      <table>
      <caption>Приоритет операторов</caption>
      <thead>
      <tr>
        <th scope="col">Тип оператора</th>
        <th scope="col">Операторы</th>
      </tr>
      </thead>
      <tbody>
      <tr>
        <td>свойство объекта</td>
        <td><code>. []</code></td>
      </tr>
      <tr>
        <td>вызов, создание экземпляра объекта</td>
        <td><code>() new</code></td>
      </tr>
      <tr>
        <td>отрицание, инкремент</td>
        <td><code>! ~ - + ++ -- typeof void delete</code></td>
      </tr>
      <tr>
        <td>умножение, деление</td>
        <td><code>* / %</code></td>
      </tr>
      <tr>
        <td>сложение, вычитание</td>
        <td><code>+ -</code></td>
      </tr>
      <tr>
        <td>побитовый сдвиг</td>
        <td><code>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</code></td>
      </tr>
      <tr>
        <td>сравнение, вхождение</td>
        <td><code>&lt; &lt;= &gt; &gt;= in instanceof</code></td>
      </tr>
      <tr>
        <td>равенство</td>
        <td><code>== != === !==</code></td>
      </tr>
      <tr>
        <td>битовое-и</td>
        <td><code>&amp;</code></td>
      </tr>
      <tr>
        <td>битовое-исключающее-или</td>
        <td><code>^</code></td>
      </tr>
      <tr>
        <td>битовое-или</td>
        <td><code>|</code></td>
      </tr>
      <tr>
        <td>логическое-и</td>
        <td><code>&amp;&amp;</code></td>
      </tr>
      <tr>
        <td>логическое-или</td>
        <td><code>||</code></td>
      </tr>
      <tr>
        <td>условный (тернарный) оператор</td>
        <td><code>?:</code></td>
      </tr>
      <tr>
        <td>присваивание</td>
        <td><code>= += -= *= /= %= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= &amp;= ^= |=</code></td>
      </tr>
      <tr>
        <td>запятая</td>
        <td><code>,</code></td>
      </tr>
      </tbody>
    </table>
    `,
  },

  {
    id: 41,
    title: 'Map',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    links: [
      {
        label: 'Learn Javascript',
        href: 'https://learn.javascript.ru/map-set#map',
      },
    ],
    answer: `
      <p><strong>Map</strong> – это коллекция ключ/значение, как и Object. Но основное отличие в том, что Map позволяет использовать ключи любого типа.</p>

      <p><strong>Зачем он нужен?</strong></p>
      <p>Более защищеный объект, свойства случайно не перезапишутся. Можно использовать объекты как ключи, тогда мы можем безопасно приписать объекту свойства, не меняя самого объекта. Иными словами - дополнительное хранилище данных (правда лучше все-таки WeakMap бо ключ объект). Кеширование результатов функций объекта (тоже лучше WeakMap)</p>

      <p><strong>Методы и свойства:</strong></p>
      <p><code>new Map()</code> – создаёт коллекцию. <br/>
      <code>map.set(key, value)</code> – записывает по ключу key значение value.<br/>
      <code>map.get(key)</code> – возвращает значение по ключу или undefined, если ключ key отсутствует.<br/>
      <code>map.has(key)</code> – возвращает true, если ключ key присутствует в коллекции, иначе false.<br/>
      <code>map.delete(key)</code> – удаляет элемент по ключу key.<br/>
      <code>map.clear()</code> – очищает коллекцию от всех элементов.<br/>
      <code>map.size</code> – возвращает текущее количество элементов.</p>

      <p><strong>Перебор Map</strong></p>
      <p><code>map.keys()</code> – возвращает итерируемый объект по ключам,<br/>
      <code>map.values()</code> – возвращает итерируемый объект по значениям,<br/>
      <code>map.entries()</code> – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of.</p>
    
      <p><strong>Преобразования</strong></p>
      <p><code>let map = new Map(Object.entries(obj));</code> - из объекта в Map<br/>
      <code>let obj = Object.fromEntries(map.entries());</code> - из Map в объект</p>
      `,
  },

  {
    id: 42,
    title: 'Set',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    links: [
      {
        label: 'Learn Javascript',
        href: 'https://learn.javascript.ru/map-set#set',
      },
    ],
    answer: `
      <p><strong>Set</strong> – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.</p>

      <p><strong>Зачем он нужен?</strong></p>
      <p>Защищенная коллекция уникальных элементов. Точно не будет одинакового</p>

      <p><strong>Методы и свойства:</strong></p>
      <p><code>new Set(iterable)</code> – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый Set.<br/>
      <code>set.add(value)</code> – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.<br/>
      <code>set.delete(value)</code> – удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false.<br/>
      <code>set.has(value)</code> – возвращает true, если значение присутствует в множестве, иначе false.<br/>
      <code>set.clear()</code> – удаляет все имеющиеся значения.<br/>
      <code>set.size</code> – возвращает количество элементов в множестве.</p>

      <p><strong>Перебор объекта Set</strong></p>
      <p><code>for (let value of set) {...}</code> <br/>
      <code>set.forEach(func)</code><br/>
      <code>set.values()</code> – возвращает перебираемый объект для значений,<br/>
      <code>set.keys()</code> – то же самое, что и set.values(), присутствует для обратной совместимости с Map,<br/>
      <code>set.entries()</code> – возвращает перебираемый объект для пар вида [значение, значение], присутствует для обратной совместимости с Map.
      </p>
    
      <p><strong>Преобразования</strong></p>
      <p><code>let set = new Set(arr);</code> - из массива в Set<br/>
      <code>let arr = Array.from(set);</code> - из Set в массив</p>
      `,
  },

  {
    id: 43,
    title: 'WeakMap и WeakSet',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    links: [
      {
        label: 'Learn Javascript',
        href: 'https://learn.javascript.ru/weakmap-weakset',
      },
    ],
    answer: `
      <p><strong>WeakMap</strong> – Тоже что и Map, но ключи могут быть только объектами. Позволяет удалить объект-ключ сборщиком мусора, по необходимости, чего нельзя в обычном Map.</p>

      <p><strong>Зачем он нужен?</strong></p>
      <p>Можем безопасно приписать объекту свойства, не меняя самого объекта. Иными словами - дополнительное хранилище данных. Кеширование результатов функций объекта.</p>

      <p><strong>WeakSet</strong> – Тоже что и Set, но элементы могут быть только объектами. Позволяет удалить объект-элемент сборщиком мусора, по необходимости, чего нельзя в обычном Set.</p>
      
      <p><strong>Зачем он нужен?</strong></p>
      <p>Будучи «слабой» версией оригинальной структуры данных, она тоже служит в качестве дополнительного хранилища. Но не для произвольных данных, а скорее для значений типа «да/нет». Присутствие во множестве WeakSet может что-то сказать нам об объекте.
      Например, мы можем добавлять пользователей в WeakSet для учёта тех, кто посещал наш сайт</p>
      `,
  },

  {
    id: 44,
    title: 'Deep (глубокое) и shallow (поверхностное) копирование',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    links: [
      {
        label: 'Learn Javascript',
        href: 'https://learn.javascript.ru/object-copy',
      },
      {
        label: 'Ссылка 2',
        href: 'https://doka.guide/js/shallow-or-deep-clone/#:~:text=%D0%9A%D1%80%D0%B0%D1%82%D0%BA%D0%BE,-%D0%A1%D0%B5%D0%BA%D1%86%D0%B8%D1%8F%20%D1%81%D1%82%D0%B0%D1%82%D1%8C%D0%B8%20%22%D0%9A%D1%80%D0%B0%D1%82%D0%BA%D0%BE&text=%D0%9F%D1%80%D0%B8%20%D0%BA%D0%BE%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B8%20%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2%20%D0%B8%D0%BB%D0%B8%20%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%BE%D0%B2,deep)%20%D0%B8%D0%BB%D0%B8%20%D0%BF%D0%BE%D0%BB%D0%BD%D0%BE%D0%B5%20%D0%BA%D0%BE%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85.',
      },
    ],
    answer: `
      <p>
        При копировании объектов или массивов JavaScript копирует данные только на один уровень вглубь. Этот тип копирования называется поверхностным (shallow).
        Если необходимо полностью скопировать сложную структуру данных, например, массив с объектами, то нужно делать глубокое (deep) или полное копирование данных. JavaScript не содержит функций для глубокого копирования, лучший вариант сделать глубокую копию — сериализовать структуру в JSON и тут же распарсить.
      </p>

      <p><strong>Примеры поверхностного копирования</strong></p>
      <ol>
        <li>Деструктуризация</li>
        <li>Object.assign(dest, [src1, src2, src3...])</li>
        <li>Самостоятельно пройтись какими-либо перебирающими циклами for, map, forEach ...</li>
      </ol>

      <p><strong>Примеры глубокого копирования</strong></p>
      <ol>
        <li>JSON.parse(JSON.stringify(obj))</li>
        <li>_.cloneDeep(obj) из lodash</li>
      </ol>
      `,
  },

  {
    id: 45,
    title: 'Сравнение Function Decaration и Function Expression',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://behemothoz.gitbooks.io/js-learn/content/chapter1/raznitsa-mezhdu-function-expression-i-function-declaration.html',
      },
    ],
    answer: `
      <p><strong>Function Declaration</strong> - функция, объявленная в основном потоке кода.</p>
      <p><strong>Function Expression</strong> -  объявление функции в контексте какого-либо выражения, например присваивания.</p>
      <p>
        <code>
          // Function Declaration <br/>
          function sum(a, b) { <br/>
            return a + b; <br/>
          } <br/>
          <br/>
          // Function Expression <br/>
          var sum = function(a, b) { <br/>
            return a + b; <br/>
          }
        </code>
      </p>
      
      <p>
        Основное отличие между ними: функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода.
        Поэтому их можно вызвать до объявления. Function Expression создаются в процессе выполнения выражения, в котором созданы.
        Благодаря этому свойству Function Expression можно (и даже нужно) использовать для условного объявления функции.
      </p>
    `,
  },

  {
    id: 46,
    title: 'Что такое анонимная функция?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    links: [
      {
        label: 'Medium (копание)',
        href: 'https://medium.com/devschacht/anonymous-functions-in-javascript-ff6b9ba85de0',
      },
    ],
    answer: `
      <p>Если после function есть имя — функция именованная, во всех остальных случая анонимная.</p>
      <p>Используется </p>
      <ul>
        <li>если мы не хотим засорять неймспейс</li>
        <li>название как таковое не сильно нужно</li>
        <li>нужно сделать самое простое замыкание/li>
      </ul>
    `,
  },

  {
    id: 47,
    title: 'Стрелочные (arrow) функции',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    links: [
      {
        label: 'MDN',
        href: 'https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Arrow_functions',
      },
      {
        label: 'w3s',
        href: 'https://www.w3schools.com/js/js_arrow_function.asp',
      },
    ],
    answer: `
      <p>Это более короткие анонимные function expression, которые не имеют своего this, arguments, super и new.target. </p>
      <p>Вызов через new невозможен. Ключевое слово yield не может быть использовано в теле функции</p>
      <p>this у стрелочных функций и привязать его нельзя. Сам по себе this будет принадлежать тому объекту, который ОПРЕДЕЛИЛ эту функцию.</p>
    `,
  },

  {
    id: 48,
    title:
      'Что такое и для чего используют IIFE (Immediately Invoked Function Expression)?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    links: [
      {
        label: 'MDN',
        href: 'https://developer.mozilla.org/ru/docs/Glossary/IIFE',
      },
    ],
    answer: `
      <p>IIFE (Immediately Invoked Function Expression) это JavaScript функция, которая выполняется сразу же после того, как она была определена.</p>
      <p>
        <code>
          (function () { <br/>
            statements<br/>
          })();
        </code>
      </p>
      <p>Зачем?</p>
      <ul>
          <li>Функция становится мгновенно выполняющимся функциональным выражением. </li>
          <li>Переменные внутри функции не могут быть использованы за пределами её области видимости.</li>
      </ul>
      <p>Переменная, которой присвоено IIFE, хранит в себе результат выполнения функции, но не саму функцию.</p>
    `,
  },

  {
    id: 49,
    title: 'Что такое hoisting, как он работает для переменных и функций?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    links: [
      {
        label: 'Medium',
        href: 'https://medium.com/@stasonmars/%D1%80%D0%B0%D0%B7%D0%B1%D0%B8%D1%80%D0%B0%D0%B5%D0%BC%D1%81%D1%8F-%D1%81-%D0%BF%D0%BE%D0%B4%D0%BD%D1%8F%D1%82%D0%B8%D0%B5%D0%BC-hoisting-%D0%B2-javascript-7d2d27bc51f1#:~:text=%D0%9F%D0%BE%D0%B4%D0%BD%D1%8F%D1%82%D0%B8%D0%B5%20%D0%B8%D0%BB%D0%B8%20hoisting%20%E2%80%94%20%D1%8D%D1%82%D0%BE%20%D0%BC%D0%B5%D1%85%D0%B0%D0%BD%D0%B8%D0%B7%D0%BC,%D1%82%D0%B5%D0%BC%2C%20%D0%BA%D0%B0%D0%BA%20%D0%BA%D0%BE%D0%B4%20%D0%B1%D1%83%D0%B4%D0%B5%D1%82%20%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD.',
      },
      {
        label: 'MDN',
        href: 'https://developer.mozilla.org/ru/docs/Glossary/Hoisting',
      },
    ],
    answer: `
      <p>Hoisting (поднятие, всплытие) — это механизм в JavaScript, в котором переменные и объявления функций, передвигаются вверх своей области видимости перед тем, как код будет выполнен.</p>
      <p>Как следствие, это означает то, что совершенно неважно где были объявлены функция или переменные, все они передвигаются вверх своей области видимости, вне зависимости от того локальная она или же глобальная.
      Стоит отметить то, что механизм “поднятия” передвигает только объявления функции или переменной. Назначения переменным остаются на своих местах.</p>
      <p>JavaScript непреклонно сначала объявляет, а уже затем инициализирует наши переменные. Поднятие происходит именно ДЕКЛАРИРОВАНИЯ (объявления), а не инициализации / присвоения значения</p>
      
      <br/>
      <p>Таким образом, мы легко можем использовать function declaration выше её фактического места в коде</p>
      <p>function expresstion выдаст что она undefined</p>
      <p>Но при использовании переменных, значение до инициализаци будет undefined. В стрикт моде выдаест просто эррор, что не объявлена переменная. Стоит уточнить, что стрикт мод включится при использовании ES6+ фич, таких как let, const и пр.</p>
      `,
  },

  {
    id: 50,
    title: 'Что такое замыкание (closure)?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    links: [
      {
        label: 'Learn Javascript',
        href: 'https://learn.javascript.ru/closure',
      },
      {
        label: 'MDN',
        href: 'https://developer.mozilla.org/ru/docs/Web/JavaScript/Closures',
      },
      {
        label: 'Ссылка 3',
        href: 'https://itchief.ru/javascript/closure#:~:text=%D0%97%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F%20%D0%B2%20JavaScript%20%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE%20%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C%20%D0%B4%D0%BB%D1%8F%20%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%B2%D0%B0%D1%82%D0%BD%D1%8B%D1%85%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85%20%D0%B8%20%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9.',
      },
    ],
    answer: `
      <p>Замыкание это функция у которой есть доступ к своей внешней функции по области видимости, даже после того, как внешняя функция прекратилась. Это говорит о том, что замыкание может запоминать и получать доступ к переменным, и аргументам своей внешней функции, даже после того, как та прекратит выполнение.</p>
      <p>Функция замыкает в себе лексическое окружение, и когда будет вызвана снова, то сможет использовать предыдущие переменные, (контекст, лексическое окружение) и модифицировать их на основе предыдущих значений</p>
      <p>Получается такая некая инициализация функции. А потом ее последующие вызовы</p>

      <p>
        <code>
          function makeCounter() { <br/>
            let count = 0;<br/>
            return function() {<br/>
              return count++;<br/>
            };<br/>
          }<br/>
          <br/>
          let counter1 = makeCounter();<br/>
          let counter2 = makeCounter();<br/>
          <br/>
          alert( counter1() ); // 0<br/>
          alert( counter1() ); // 1<br/>
          <br/>
          alert( counter2() ); // 0 (независимо)
        </code>
      </p>

      <p>Применение: счетчики, кешаторы, функции требующие инициализаторы, функции, которые могут работать параллельно но с другими данными. Может быть полезно при создании модалок (разные по контенту, но принцип работы один)</p>
      `,
  },

  {
    id: 51,
    title: 'Что такое рекурсия?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    links: [
      {
        label: 'Learn Javascript',
        href: 'https://learn.javascript.ru/recursion#:~:text=%D0%A2%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D1%8B%3A,%D1%81%D0%B5%D0%B1%D1%8F%2C%20%D1%8D%D1%82%D0%BE%20%D0%BD%D0%B0%D0%B7%D1%8B%D0%B2%D0%B0%D0%B5%D1%82%D1%81%D1%8F%20%D1%88%D0%B0%D0%B3%D0%BE%D0%BC%20%D1%80%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D0%B8.',
      },
    ],
    answer: `
      <p>Рекурсия – это термин в программировании, означающий вызов функцией самой себя. Рекурсивные функции могут быть использованы для элегантного решения определённых задач.</p>
      <p>Когда функция вызывает саму себя, это называется шагом рекурсии. База рекурсии – это такие аргументы функции, которые делают задачу настолько простой, что решение не требует дальнейших вложенных вызовов.</p>
      <p>Рекурсивное решение - когда повторение действия происходит через самовызов функции. Итеративное - когда через специальный метод цикла. Рекурсивный метод как правило бывает короче</p>
      <p>Примеры из жизни: мы делаем чек статуса и обновляем таблицу. Пока статус не будет success - мы перевызываем функцию с чеком статуса</p>
      `,
  },

  {
    id: 52,
    title: 'Что такое this?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    links: [
      {
        label: 'MDN',
        href: 'https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/this',
      },
      {
        label: 'Ссылка 2',
        href: 'https://habr.com/ru/company/ruvds/blog/419371/',
      },
    ],
    answer: `
      <p>This можно считать динамическим ключевым словом. Мне нравится, как понятие «контекст» раскрыто в этой статье Райана Морра. По его словам, контекст всегда является значением ключевого слова this, которое ссылается на объект, «владеющий» кодом, выполняемым в текущий момент. Однако, тот контекст, который имеет отношение к this, это не то же самое, что контекст выполнения.</p>
      <p>В <strong>глобальном контексте</strong> выполнения (за пределами каких-либо функций) this ссылается на глобальный объект (window) вне зависимости от режима (строгий или нестрогий).</p>  
      <p>В пределах <strong>функции</strong> значение this зависит от того, каким образом вызвана функция. Не в строгом режиме, и значение this не устанавливается вызовом, по умолчанию будет использоваться объект global, которым в браузере является window. В строгом режиме, если значение this не установлено в контексте выполнения, оно остаётся undefined. Для того, чтобы при вызове функции установить this в определённое значение, используйте bind(), call() или apply()</p>
      <p>В <strong>стрелочных функциях</strong>, this привязан к окружению, в котором была создана функция. В глобальной области видимости this будет указывать на глобальный объект.</p>
      <p>Когда <strong>функция вызывается как метод объекта</strong>, используемое в этой функции ключевое слово this принимает значение объекта, по отношению к которому вызван метод.</p>
      <p>Когда <strong>функция используется как конструктор</strong> (с ключевым словом new ), this связано с создаваемым новым объектом.</p>
      <p>Когда функция используется как <strong>обработчик событий</strong>, this присваивается элементу с которого начинается событие (некоторые браузеры не следуют этому соглашению для обработчиков, добавленных динамически с помощью всех методов, кроме addEventListener).</p>
      <p>Когда код вызван из <strong>инлайнового обработчика</strong>, this указывает на DOM-элемент, в котором расположен код события</p>
      `,
  },

  {
    id: 53,
    title:
      'Что такое потеря контекста, когда происходит и как её предотвратить?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    answer: `
      <p>Значение this внутри функции зависит от того как вызывается функция и как создана функция.</p>
      <p>
        <strong>Как вызывается?</strong><br/>
        Вызвать функцию можно следующими способами:<br/>
        <br/>
        <strong>Вызов функции</strong><br/>
        Если есть обычная функция, в большинстве случаев значением this будет глобальный объект (для браузера window). При использовании "strict mode" - undefined.<br/>
        <br/>
        Обычно так вызываются функции обратного вызова(callback), вот почему значение this в них кажется неожиданным.<br/>
        <br/>
        Например, при передаче функции в .addEventListener, значением this будет элемент, которому добавлен обработчик.<br/>
        <br/>
        <strong>Вызов метода</strong><br/>
        Метод - это функция находящаяся в объекте.<br/>
        <br/>
        Когда функция вызывается как метод, значением this является объект в котором находится функция, фактически значение перед символом точки.
        <br/>
        <strong>Вызов конструктора</strong><br/>
        Функцию можно вызывать в качестве конструктора, для этого перед вызовом нужно использовать оператор new: new Foo()<br/>
        <br/>
        При вызове функции в качестве конструктора создается новый объект, и значение this ссылается на это созданный объект.<br/>
        <br/>
        Особенность: при использовании наследования и классов из ES2015 обращение к this до вызова super в зависимости от браузера вызовет исключение о попытке обратиться к необъявленной/неинициализированной переменной.<br/>
        <br/>
        <strong>Вызов с помощью методов call и apply</strong><br/>
        При использовании функций call и apply можно задать значение this напрямую, передав его первым параметром.<br/>
        <br/>
        В библиотеках вроде jQuery с помощью этих функций вызываются коллбэки передаваемые в различные функции, например: each, map, on и другие. В качестве this в этом случае устанавливается текущий элемент коллекции, либо html-элемент.<br/>
        <br/>
        <strong>Вызов в качестве коллбэков в функциях обработки массивов</strong><br/>
        Некоторые встроенные функции для объекта типа Array позволяют так же напрямую указать значение this для передаваемого коллбэка:<br/>
        <br/>
        <code>
          Array.every<br/>
          Array.filter<br/>
          Array.find<br/>
          Array.findIndex<br/>
          Array.forEach<br/>
          Array.map<br/>
          Array.some
        </code><br/>
        <br/>
        <strong>Как создается?</strong><br/>
        <strong>Объявление функции или функционального выражения</strong><br/>
        Обычное объявление функции:<br/>
        <br/>
        <code>function A(){}</code><br/>
        <br/>
        <code>var a = function (){};</code><br/>
        при обычном объявлении значение this определяется при вызове способами описанными выше.<br/>
        <br/>
        <strong>Создание функции с помощью bind</strong><br/>
        Функция bind возвращает новую привязанную функцию. Значение this внутри созданной функции всегда то, которое передали при вызове bind.<br/>
        <br/>
        Важная особенность: при использовании привязанной функции в качестве конструктора, значение this все равно будет указывать на создаваемый объект, как описано выше.<br/>
        <br/>
        Важная особенность: в НЕ strict mode при передаче в качестве параметра this значений null и undefined - этот параметр будет проигнорирован и this будет установлен в глобальный объект.<br/>
        <br/>
        Важная особенность: значение this у созданной функции нельзя переопределить используя функции call и apply описанные выше.<br/>
        <br/>
        <strong>Стрелочные функции</strong><br/>
        Стрелочные функции появились в ES2015 и при создании привязываются к текущему значению this.<br/>
        <br/>
        После создания значение this нельзя поменять указанными выше способами.<br/>
        <br/>
        Кроме того стрелочную функцию нельзя использовать в качестве конструктора.
      </p>
    `,
  },

  {
    id: 54,
    title: 'Методы функций bind/call/apply – зачем и в чем разница?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 1,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://www.8host.com/blog/kak-rabotaet-this-bind-call-i-apply-v-javascript/',
      },
    ],
    answer: `
      <p><strong>call и apply</strong> очень похожи – они вызывают функцию с указанным контекстом this и дополнительными аргументами. Единственная разница между call и apply заключается в том, что call требует, чтобы аргументы передавались по одному, а apply принимает их в виде массива.
      </p>
      <p>И call, и apply являются одноразовыми методами – если вы вызываете метод с контекстом this, он примет его, но исходная функция останется неизменной.
      В отдельных ситуациях вам может понадобиться несколько раз использовать метод с контекстом this другого объекта. В таком случае вы можете использовать метод <strong>bind</strong> для создания новой функции с явно привязанным this. Иными словами, bind привязывает контекст, но не вызывает функцию</p>
      `,
  },

  {
    id: 55,
    title: 'Что такое DOM?',
    category: [QuizletQuestionCategoryEnum.frontend],
    level: 1,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://itchief.ru/javascript/dom',
      },
    ],
    answer: `
      <p>Браузер, когда запрашивает страницу и получает в ответе от сервера её исходный HTML-код, должен сначала его разобрать. В процессе анализа и разбора HTML-кода браузер строит на основе него DOM-дерево.</p>
      <p><strong>DOM</strong> – это объектная модель документа, которую браузер создаёт в памяти компьютера на основании HTML-кода, полученного им от сервера.</p>
      `,
  },

  {
    id: 56,
    title: 'Async и defer',
    category: [QuizletQuestionCategoryEnum.frontend],
    level: 1,
    links: [
      {
        label: 'Learn javascript',
        href: 'https://learn.javascript.ru/script-async-defer',
      },
    ],
    answer: `
      <p>Когда браузер загружает HTML и доходит до тега <script>...</script>, он не может продолжать строить DOM. Он должен сначала выполнить скрипт. То же самое происходит и с внешними скриптами <script src="..."></script>: браузер должен подождать, пока загрузится скрипт, выполнить его, и только затем обработать остальную страницу.</p>
      <p>Это ведёт к двум важным проблемам:
        <ol>
          <li>Скрипты не видят DOM-элементы ниже себя, поэтому к ним нельзя добавить обработчики и т.д.</li>
          <li>Если вверху страницы объёмный скрипт, он «блокирует» страницу. Пользователи не видят содержимое страницы, пока он не загрузится и не запустится</li>
        </ol>
      </p>
      <p>Конечно, есть пути, как это обойти. Например, мы можем поместить скрипт внизу страницы. Тогда он сможет видеть элементы над ним и не будет препятствовать отображению содержимого страницы. Но это решение далеко от идеального. Например, браузер замечает скрипт (и может начать загружать его) только после того, как он полностью загрузил HTML-документ. В случае с длинными HTML-страницами это может создать заметную задержку.
      Такие вещи незаметны людям, у кого очень быстрое соединение, но много кто в мире имеет медленное подключение к интернету или использует не такой хороший мобильный интернет.
      К счастью, есть два атрибута тега script, которые решают нашу проблему: defer и async</p>

      <p><strong>defer</strong> - Атрибут defer сообщает браузеру, что он должен продолжать обрабатывать страницу и загружать скрипт в фоновом режиме, а затем запустить этот скрипт, когда DOM дерево будет полностью построено. Скрипты запускаются по очереди как расположены в документе</p>
      <p><strong>async</strong> - похож на defer, но скрипт запуститься не после построения дом-дерева, а в момент полной загрузки. При наличии нескольких скриптов, первым запустится самый маленький (потому что быстрее загрузится)</p>
      `,
  },

  {
    id: 57,
    title: 'Отличие innerHTML и innerText',
    category: [QuizletQuestionCategoryEnum.frontend],
    level: 1,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://efim360.ru/javascript-chem-otlichaetsya-innertext-ot-innerhtml/',
      },
    ],
    answer: `
      <p><strong>innerText</strong> - показывает всё текстовое содержимое, которое не относится к синтаксису HTML. То есть любой текст, заключённый между открывающими и закрывающими тегами элемента будет записан в innerText. Причём если внутри innerText будут ещё какие-либо элементы HTML со своим содержимым, то он проигнорирует сами элементы и вернёт их внутренний текст.</p>
      <p>Примеры innerText</p>
      <p>
        <code>
          spisok[0].innerText // "Холодильник - 52000 руб. (рублей)"<br/>
          spisok[1].innerText // "Телевизор - 41000 руб. (рублей)"<br/>
        </code>
      </p>
      
      <p><strong>innerHTML</strong> - покажет текстовую информацию ровно по одному элементу. В вывод попадёт и текст и разметка HTML-документа, которая может быть заключена между открывающими и закрывающими тегами основного элемента.</p>
      <p>Примеры innerHTML</p>
      <p>
        <code>
          spisok[0].innerHTML // "Холодильник - <span><b>52000</b> руб. <i style="color: red">(рублей)</i></span>"<br/>
          spisok[1].innerHTML // "Телевизор - <span><b>41000</b> руб. <i style="color: red">(рублей)</i></span>"<br/>
        </code>
      </p>
      
      `,
  },

  {
    id: 58,
    title: 'Всплытие (bubblind) и погружение (capturing)',
    category: [QuizletQuestionCategoryEnum.frontend],
    level: 1,
    links: [
      {
        label: 'Learn Javascript',
        href: 'https://learn.javascript.ru/bubbling-and-capturing',
      },
    ],
    answer: `
      <p>Три фазы прохода события:</p>
      <p>
        <ol>
          <li>Фаза погружения (capturing phase) – событие сначала идёт сверху вниз.</li>
          <li>Фаза цели (target phase) – событие достигло целевого(исходного) элемента.</li>
          <li>Фаза всплытия (bubbling stage) – событие начинает всплывать.</li>
        </ol>
      </p>
      <p><strong>Всплытие</strong> - Когда на элементе происходит событие, обработчики сначала срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков. Для того чтобы прекратить всплытие, нужно использовать event.stopPropagation()</p>
      <p><strong>Погружение</strong> - событие двигается от event.target вверх к корню документа, по пути вызывая обработчики, поставленные через on event и addEventListener без третьего аргумента или с третьим аргументом равным false</p>
    
      `,
  },

  {
    id: 59,
    title: 'Как остановить дефолтную обработку события?',
    category: [QuizletQuestionCategoryEnum.frontend],
    level: 1,
    links: [
      {
        label: 'Learn Javascript',
        href: 'https://learn.javascript.ru/default-browser-action',
      },
    ],
    answer: `
      <p>Есть два способа отменить действие браузера:</p>
      <ul>
        <li>Основной способ – это воспользоваться объектом <code>event</code>. Для отмены действия браузера существует стандартный метод <code>event.preventDefault()</code>.</li>
        <li>Если же обработчик назначен через <code>on&lt;событие&gt;</code> (не через <code>addEventListener</code>), то также можно вернуть <code>false</code> из обработчика.</li>
      </ul>
      <p>Также можно узнать, производилась ли остановка дефолтной обработки через event.defaultPrevented</p>
      `,
  },

  {
    id: 60,
    title: 'Чему равен this в обработчике событий (event handler)?',
    category: [QuizletQuestionCategoryEnum.frontend],
    level: 1,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://professorweb.ru/my/javascript/js_theory/level2/2_5.php',
      },
    ],
    answer: `
      <p>В теле обработчика событий ключевое слово this ссылается на цель события (как правило это DOM element).</p>
      <p>В обработчиках ключевое слово this ссылается на целевой объект, даже когда они были зарегистрированы с помощью метода addEventListener(). Однако, к сожалению, это не относится к методу attachEvent(): обработчики, зарегистрированные с помощью метода attachEvent(), вызываются как функции, и в них ключевое слово this ссылается на глобальный (Window) объект.</p>
      `,
  },

  {
    id: 61,
    title:
      'Что такое LocalStorage и SessionStorage? Каков максимальный размер LocalStorage?',
    category: [QuizletQuestionCategoryEnum.frontend],
    level: 1,
    links: [
      {
        label: 'Learn Javascript',
        href: 'https://learn.javascript.ru/localstorage',
      },
    ],
    answer: `
    <p>Объекты веб-хранилища <code>localStorage</code> и <code>sessionStorage</code> позволяют хранить пары ключ/значение в браузере.</p>
    <ul>
      <li><code>key</code> и <code>value</code> должны быть строками.</li>
      <li>Лимит 2 Мб+, зависит от браузера.</li>
      <li>Данные не имеют «времени истечения».</li>
      <li>Данные привязаны к источнику (домен/протокол/порт).</li>
    </ul>
    <table>
      <thead>
        <tr>
          <th><code>localStorage</code></th>
          <th><code>sessionStorage</code></th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Совместно используется между всеми вкладками и окнами с одинаковым источником</td>
          <td>Разделяется в рамках вкладки браузера, среди ифреймов из того же источника</td>
        </tr>
        <tr>
          <td>«Переживает» перезапуск браузера</td>
          <td>«Переживает» перезагрузку страницы (но не закрытие вкладки)</td>
        </tr>
      </tbody>
    </table>
    <p>API:</p>
    <ul>
      <li><code>setItem(key, value)</code> – сохранить пару ключ/значение.</li>
      <li><code>getItem(key)</code> – получить данные по ключу <code>key</code>.</li>
      <li><code>removeItem(key)</code> – удалить значение по ключу <code>key</code>.</li>
      <li><code>clear()</code> – удалить всё.</li>
      <li><code>key(index)</code> – получить ключ на заданной позиции.</li>
      <li><code>length</code> – количество элементов в хранилище.</li>
      <li>Используйте <code>Object.keys</code> для получения всех ключей.</li>
      <li>Можно обращаться к ключам как к обычным свойствам объекта, в этом случае событие<code>storage</code> не срабатывает.</li>
    </ul>
    <p>Событие storage:</p>
    <ul>
      <li>Срабатывает при вызове <code>setItem</code>, <code>removeItem</code>, <code>clear</code>.</li>
      <li>Содержит все данные об произошедшем обновлении (<code>key/oldValue/newValue</code>), <code>url</code> документа и объект хранилища <code>storageArea</code>.</li>
      <li>Срабатывает на всех объектах <code>window</code>, которые имеют доступ к хранилищу, кроме того, где оно было сгенерировано (внутри вкладки для <code>sessionStorage</code>, глобально для <code>localStorage</code>).</li>
    </ul>
    `,
  },

  {
    id: 62,
    title: 'Как получить высоту блока? Его положения о границах документа?',
    category: [QuizletQuestionCategoryEnum.frontend],
    level: 1,
    links: [
      {
        label: 'Learn Javascript',
        href: 'https://learn.javascript.ru/coordinatesp',
      },
    ],
    answer: `
    <p>Метод <code>elem.getBoundingClientRect()</code> возвращает координаты в контексте окна для минимального по размеру прямоугольника, который заключает в себе элемент <code>elem</code>, в виде объекта встроенного класса DOMRect.</p>
    <p>Основные свойства объекта типа <code>DOMRect</code>:</p>
    <ul>
      <li><code>x/y</code> – X/Y-координаты начала прямоугольника относительно окна,</li>
      <li><code>width/height</code> – ширина/высота прямоугольника (могут быть отрицательными).</li>
    </ul>
    <p>Дополнительные, «зависимые», свойства:</p>
    <ul>
      <li><code>top/bottom</code> – Y-координата верхней/нижней границы прямоугольника,</li>
      <li><code>left/right</code> – X-координата левой/правой границы прямоугольника.</li>
    </ul>
      `,
  },

  {
    id: 63,
    title: 'Что такое webpack?',
    category: [QuizletQuestionCategoryEnum.frontend],
    level: 1,
    answer: `
      <p>Webpack - это сборщик кода по заранее указанным правилам. Как правило исходный код является объемным, модульным и который не всегда может запустить браузер буз сторонней помощи. Сборщик кода может как собрать все необходимые части приложения, оптимизировать и сжать их</p>
    `,
  },

  {
    id: 64,
    title: 'Чем отличается dev-сборник от prod?',
    category: [QuizletQuestionCategoryEnum.frontend],
    level: 1,
    answer: `
      <p>Дев версия как правило содержит более обширный код с помошниками кода, линтерами и комментариями. Прод сборщик нацелен на оптимизацию и минимизацию. Также дев и прод сборки могут отличаться env переменными</p>
    `,
  },

  {
    id: 65,
    title: 'Что такое блочная модель CSS?',
    category: [QuizletQuestionCategoryEnum.markup],
    level: 1,
    answer: `
      <p>В CSS мы, говоря упрощённо, имеем два типа элементов — блочные (block) и строчные (inline). Эти характеристики относятся к поведению блоков в контексте потока страницы и относительно других блоков на странице.</p>
      <p><strong>Блочные (block)</strong> элементы имеют высоту, ширину, padding, margin, border, а также располагаются вертикально, друг под другом.</p>
      <p><strong>Строчные (inline)</strong> элементы располагаются горизонтально, друг за другом.</p>
      <p><strong>Элементы inline-block</strong> обладают характеристиками как блочных, так и строчных элементов.</p>
      `,
  },

  {
    id: 66,
    title:
      'Какие способы центрирования блочного контента по горизонтали и вертикали знаете?',
    category: [QuizletQuestionCategoryEnum.markup],
    level: 1,
    links: [
      {
        label: 'Learn Javascript',
        href: 'https://learn.javascript.ru/css-center',
      },
    ],
    answer: `
      <p>По горизонтали</p>
      <ul>
        <li>text-align: center</li>
        <li>margin: 0 auto</li>
        <li>display: flex</li>
        <li>display: grid</li>
        <li>position absolute, relative, fixed; left: 50%; margin-left: -x</li>
        <li>position absolute, relative, fixed; left: 50%; transform: translateX(-x)</li>
      </ul>

      <p>По вертикали</p>
      <ul>
        <li>display: table-cell/inline/inline-block; vertical-align: middle;</li>
        <li>line-height: x em;</li>
        <li>display: flex</li>
        <li>display: grid</li>
        <li>position absolute, relative, fixed; top: 50%; margin-top: -x</li>
        <li>position absolute, relative, fixed; top: 50%; transform: translateY(-x)</li>
      </ul>
    `,
  },

  {
    id: 67,
    title: 'Что такое семантическая вёрстка?',
    category: [QuizletQuestionCategoryEnum.markup],
    level: 1,
    answer: `
      <p>Семантическая вёрстка, или семантический HTML-код, — это подход к созданию веб-страниц на языке HTML, основанный на использовании HTML-тегов в соответствии с их семантикой (предназначением), а также предполагающий логичную и последовательную иерархию страницы. Он противопоставляется подходу, при котором написание HTML-кода определяется внешним видом веб-страницы. Для оформления веб-страниц, написанных в соответствии с семантикой, используются каскадные таблицы стилей (CSS). Стандарт HTML с самого начала включал в себя ряд семантических тегов, но большую популярность семантическая вёрстка получила после начала работ над HTML5.
      <br/>
      В качестве примера можно привести изменения в стандарте HTML, коснувшиеся, в частности, тега физического форматирования i (англ. italic, делающего текст курсивным) — вместо него теперь рекомендуется использовать тег логического форматирования em (от англ. emphasis, акцентирование). Затем с помощью CSS акцентирование можно визуально представить курсивом, полужирным начертанием, подчёркиванием; аудиально (при озвучивании текста на основе TTS-технологий) — замедлением темпа речи или более громким голосом и т. д. Эти изменения вызваны тем, что визуально курсивом оформляется не только акцентирование текста, но и, например, цитаты, для которых с HTML 4 появился тег cite.</p>
      `,
  },

  {
    id: 68,
    title:
      'Зачем нужны префиксы для некоторых CSS-свойств (-webkit-, -moz- и т.п.)?',
    category: [QuizletQuestionCategoryEnum.markup],
    level: 1,
    answer: `
      <p>Они нужны для совместимости со старыми версиями браузеров либо для конкретных элементов текущего браузера, которые явно отличаются от остальных. Например скроллеры и другие встроенные элементы</p>
      <p>-webkit-transition: all 4s ease;<br/>
      -moz-transition: all 4s ease;<br/>
      -ms-transition: all 4s ease; // Internet Explorer <br/>
      -o-transition: all 4s ease;<br/>
      transition: all 4s ease;</p>
      `,
  },

  {
    id: 69,
    title: 'Как упростить написание кроссбраузерных стилей?',
    category: [QuizletQuestionCategoryEnum.markup],
    level: 1,
    answer: `
      <ul>
        <li>Резетать стили по умолчанию</li>
        <li>Использовать миксины на кросбраузерные свойства</li>
        <li>Использовать постпроцессоры на подставление кросбраузерных свойств</li>
      </ul>
      `,
  },

  {
    id: 70,
    title: 'Что такое CSS-препроцессоры?',
    category: [QuizletQuestionCategoryEnum.markup],
    level: 1,
    answer: `
      <p>CSS препроцессор (CSS preprocessor) - это программа, которая имеет свой собственный синтаксис (syntax (en-US)), но может сгенерировать из него CSS код . Существует множество препроцессоров. Большинство из них расширяет возможности чистого CSS, добавляя такие опции как: примеси, вложенные правила, селекторы наследования и др. Эти особенности облегчают работу с CSS: упрощают чтение кода и его дальнейшую поддержку.</p>
      <p>Несколько самых популярных CSS препоцессоров:</p>
      <ul>
        <li>SASS</li>
        <li>LESS</li>
        <li>Stylus</li>
        <li>PostCSS</li>
      </ul>
      `,
  },

  {
    id: 71,
    title: 'Перечислите основные компоненты фреймворка?',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 1,
    answer: `
      <ul>
        <li><strong>Component</strong></li>
        <li><strong>Directive</strong></li>
        <li><strong>Service</strong></li>
        <li><strong>Module</strong></li>
        <li><strong>Guard</strong></li>
        <li><strong>Pipe</strong></li>
      </ul>
      `,
  },

  {
    id: 72,
    title: 'В чем разница между компонентом и директивой?',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 1,
    answer: `
      <p>Компонента имеет свой шаблон и с ним работает (как изолированное под-приложение), директива не имеет шаблона (хотя возможность есть) и ставится на чужой шаблон чтобы изменить поведение.</p>
      `,
  },

  {
    id: 73,
    title: 'Расскажите о жизненном цикле компоненты',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 1,
    answer: `
      <ul>
        <li><strong>constructor</strong> +- основной инициализатор любого объекта из класса</li>
        <li><strong>ngOnChanges</strong> - устанавливаются или изменяются значения входных свойств класса компонента</li>
        <li><strong>ngOnInit</strong> - устанавливаются "обычные" свойства; вызывается единожды вслед за первым вызовом OnChanges();</li>
        <li><strong>ngDoCheck</strong> - происходит изменения свойства или вызывается какое-либо событие;</li>
        <li><strong>ngAfterContentInit</strong> - в шаблон включается контент, заключенный между тегами компонента;</li>
        <li><strong>ngAfterContentChecked</strong> - аналогичен DoCheck(), только используется для контента, заключенного между тегами компонента;</li>
        <li><strong>ngAfterViewInit</strong> - инициализируются компоненты, которые входят в шаблон текущего компонента;</li>
        <li><strong>ngAfterViewChecked</strong> - аналогичен DoCheck(), только используется для дочерних компонентов;</li>
        <li><strong>ngOnDestroy</strong> - компонент "умирает", т. е. удаляется из DOM-дерева</li>
      </ul>
    `,
  },

  {
    id: 74,
    title:
      'Перечислите часто используемые хуки жизненного цикла компонента и расскажите, зачем они нужны?',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 1,
    answer: `
      <ul>
        <li><strong>ngOnChanges</strong> - когда нужна реакция на изменения входной проперти</li>
        <li><strong>ngOnInit</strong> - когда что-либо нужно сделать при инициализации</li>
        <li><strong>ngAfterViewInit</strong> - когда нужно взаимодействовать с элементами html</li>
        <li><strong>ngOnDestroy</strong> - когда нужно сделать отписки, остановки таймеров</li>
      </ul>
    `,
  },

  {
    id: 75,
    title: 'В чем разница между конструктором и ngOnInit-хуком?',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 1,
    answer: `
      <p>
        <strong>Конструктор</strong> - это новая вещь, появившаяся после того, как в ES6 была введена концепция классов. Это свойство самого класса и не относится к категории Angular, поэтому Angular не имеет возможности управлять конструктором.
        <br/>  
        Согласно официальному заявлению, роль ngOnInit:
        <br/>
        <strong>ngOnInit</strong> используется для инициализации инструкций / компонентов после того, как Angular впервые отображает привязку данных и устанавливает входные свойства инструкций / компонентов.
        <br/>
        ngOnInit является частью жизненного цикла Angular, он вызывается после завершения первого раунда ngOnChanges и вызывается только один раз
        <br/>
        Несмотря на то, что Angular определяет ngOnInit, у конструктора есть свое место. Его основная функция - вводить зависимости.
      </p>
    `,
  },

  {
    id: 76,
    title:
      'Как защитить роут от несанкционированного доступа? Какие механизмы предоставляет для этого фреймворк?',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 1,
    answer: `
      <p>
        Нужно использовать guard межанизм, который ставится в роутинг-модуле на нужный роут. Гвард можен возвращать как булево, так и промис с булевым либо обзервер с булевыи
      </p>
    `,
  },

  {
    id: 77,
    title: 'Что такое Lazy loading, как и для чего используется?',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 1,
    answer: `
      <p>
        Это загрузка кода одного из МОДУЛЕЙ приложения по запросу, а не сразу при первом обращении.
        <br/>
        Прописывается в роутинг-модуле:<br/>
        <code>
          const routes: Routes = [<br/>
            {<br/>
              path: 'items',<br/>
              loadChildren: () => import('./items/items.module').then(m => m.ItemsModule)<br/>
            }<br/>
          ];
        </code>
      </p>
    `,
  },

  {
    id: 78,
    title: 'Какое предназначение RouterOutlet?',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 1,
    answer: `
      <p>
        Это компонент, который указывает место для дочерних роут-компонентов, которые задаст роутер-модуль
      </p>
    `,
  },

  {
    id: 79,
    title: 'Как компоненты могут взаимодействовать друг с другом?',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 1,
    answer: `
      <ul>
        <li>Через @Input() - @Output()</li>
        <li>Через @ViewChild() - Использование @ViewChild() в родительском Angular component позволяет получить все свойства указанного дочернего компонента.</li>
        <li>Через сервисы</li>
        <li>Через редакс</li>
        <li>Через localstorage</li>
      </ul>
    `,
  },

  {
    id: 80,
    title: 'Как создать two-way binding свойство для компонента?',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 1,
    answer: `
      <p>
        Механизм двустороннего связывания (angular two way binding) используется, когда необходимо отобразить свойство в шаблоне (одностороннее связывание) и обновить его при изменении значения (возникновение события) без перезагрузки страницы.
      </p>
      <p>
        Синтаксис двустороннего связывания представляет собой слияние [] одностороннего связывания и () привязки события.
      </p> 
      <p>
        <code>
          contacts-item [(name)]="contactPerson" /contacts-item
        </code><br/>
        Запись [(name)]="contactPerson" означает, что при изменении name в компоненте contacts-item его значение будет присвоено свойству contactPerson компонента, в который входит contacts-item.
      </p>
      <p>
        Для двустороннего связывания в полях формы используется встроенная в Angular директива NgModel.
        <br/>
        <code>
          input type="text" [(ngModel)]="contactPerson" 
        </code>
      </p>
    `,
  },

  {
    id: 81,
    title:
      'Какие типы форм имеются во фреймворке? В каких случаях и что лучше использовать?',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 1,
    answer: `
      <p>Angular предоставляет два разных подхода по работе с формами: реактивные формы (reactive forms) и формы на основе шаблонов (template-driven forms).</p>
    
      <ul>
        <li><strong>Реактивные формы</strong> обеспечивают прямой явный доступ к модели данных формы. По сравнению с формами на основе шаблонов, они более надежны: они масштабируемы, допускают повторное использование и хорошо тестируются. Если формы являются основной частью вашего приложения или вы уже используете реактивные шаблоны для создания приложения (реактивное программирование, rxjs), то используйте реактивные формы.</li>
        <li><strong>Формы на основе шаблонов</strong> полагаются на директивы в шаблоне для создания модели данных и управления ею. Они полезны при создании в приложении простой формы, например, формы подписки на рассылку новостей. Формы на основе шаблонов очень просты в создании, но они не так хорошо масштабируются, как реактивные формы. Если у вас очень простая логика в форме, которой можно управлять непосредственно в шаблоне, то данный вид форм подходит вам.</li>
      </ul>
      `,
  },

  {
    id: 82,
    title: 'Какие состояния есть у формы и как это можно применить?',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 1,
    answer: `
      <ul>
        <li><p>Если элемент ввода еще не получал фокус, то устанавливается класс <strong>ng-untouched</strong>. Если же поле ввода уже получало фокус, то к нему применяется 
        класс <strong>ng-touched</strong>. При этом получение фокуса не обязательно должно сопровождаться изменением значения в этом поле.</p></li>
        <li><p>Если первоначальное значение в поле ввода было изменено, то устанавливается класс <strong>ng-dirty</strong>. Если же значение не изменялось с момента загрузки страницы, 
        то к элементу ввода применяется класс <strong>ng-pristine</strong></p></li>
        <li><p>Если значение в поле ввода корректно, то применяется класс <strong>ng-valid</strong>. Если же значение некорректно, то применяется класс 
        <strong>ng-invalid</strong></p></li>
      </ul>
    `,
  },

  {
    id: 83,
    title: 'Зачем нужны сервисы?',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 1,
    answer: `
    <p>Сервисы в Angular представляют довольно широкий спектр классов, которые выполняют некоторые специфические задачи, 
    например, логгирование, работу с данными и т.д.</p>
    <p>В отличие от компонентов и директив сервисы не работают с представлениями, то есть с разметкой html, не оказывают на нее прямого влияния. Они выполняют строго определенную и 
    достаточно узкую задачу.</p>
    <p>Стандартные задачи сервисов:</p>
    <ul>
      <li><p>Предоставление данных приложению. Сервис может сам хранить данные в памяти, либо для получения данных может обращаться к какому-нибудь источнику данных, 
      например, к серверу.</p></li>
      <li><p>Сервис может представлять канал взаимодействия между отдельными компонентами приложения</p></li>
      <li><p>Сервис может инкапсулировать бизнес-логику, различные вычислительные задачи, задачи по логгированию, которые лучше выносить из компонентов. Тем самым код компонентов 
      будет сосредоточен непосредственно на работе с представлением. Кроме того, тем самым мы также можем решить проблему повторения кода, если нам потребуется выполнить одну и ту же задачу в разных компонентах и классах</p></li>
    </ul>
    `,
  },

  {
    id: 84,
    title:
      'Что такое singleton-сервисы? Каково их предназначение? Способ создания?',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 1,
    answer: `
    <p> Singleton - это класс, который позволяет создавать только один его экземпляр и предоставляет доступ к этому созданному экземпляру. Он содержит статические переменные, которые могут содержать уникальные и частные экземпляры самого себя. Он используется в сценариях, когда пользователь хочет ограничить создание экземпляра класса только одним объектом. </p>
    <p> Одноэлементный сервис - это экземпляр сервиса, который совместно используется компонентами. </p>
    <p> <strong>Предоставление единого сервиса</strong> </p>
    <p> В Angular существует два способа сделать сервис одиночным: </p>
    <ul>
      <li> Объявите корень для значения свойства @Injectable () предоставленного </li>
      <li> Включите сервис в AppModule или в модуль, который импортируется только AppModule </li>
    </ul>
    `,
  },

  {
    id: 85,
    title: 'Зачем нужны модули? Сколько их должно быть в проекте?',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 1,
    answer: `
    <p>Модули Angular помогают разбивать приложение на части (модули), которые взаимодействуют между собой и представляют в конечном итоге целостное приложение. Иными словами, модуль — это упаковка или инкапсуляция части функционала приложения. Модули можно проектировать с учетом многократного использования, т.е. не зависящие от конкретной реализации приложения. </p>
    <p>Корневой модуль в приложении Angular используется в качестве точки входа. Модуль — это класс, который декорирован при помощи @NgModule. </p>
    `,
  },

  {
    id: 86,
    title: 'Зачем нужны общие модули (shared)?',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 1,
    answer: `
      <p>Все переиспользуемые в проекте компоненты можно хранить в одном модуле, экспортируя их из него и импортируя его в те модули проекта, где эти компоненты могут понадобиться.</p>
      <p>В такой модуль можно поместить компоненты кнопки, выпадающего списка, какого нибудь стилизованного блока текста и т.д, а также кастомные директивы и пайпы.</p>
      <p>Такой модуль обычно имеет название SharedModule.</p>
    `,
  },

  {
    id: 87,
    title: 'Какие преимущества типизации в TypeScript?',
    category: [QuizletQuestionCategoryEnum.typescript],
    level: 1,
    answer: `
      <ul>
        <li>TypeScript поддерживает статическую типизацию</li>
        <li>TypeScript делает код проще для чтения и понимания</li>
        <li>TypeScript помогает избежать множества болезненных багов, которые обычно совершают разработчики, благодаря проверке типов в коде</li>
        <li>TypeScript поощряет разработчиков следовать лучшим ООП практикам</li>
        <li>Как следствие вышеперечисленного — TypeScript экономит время разработчиков</li>
      </ul>
    `,
  },

  {
    id: 88,
    title: 'Какая разница между интерфейсом и классом?',
    category: [QuizletQuestionCategoryEnum.typescript],
    level: 1,
    answer: `
      <p>
      <strong>Интерфейсы:</strong> позволяют определить тип, который будет использоваться во время разработки при компиляции для строгой типизации. Они могут быть "реализованы" или "расширены", но не могут создавать новые объекты (например через new). Они удаляются при переносе в JS, поэтому они не занимают места, но они также не могут быть проверены на тип во время выполнения, поэтому вы не можете проверить, реализует ли переменная определенный тип во время выполнения (например, foo instanceof bar), за исключением проверки свойства, которые он имеет: Проверка типа интерфейса с помощью Typescript.
      </p>
      <p>
      <strong>Когда использовать интерфейсы:</strong> используйте их, когда вам нужно создать простейшую связь свойств и функций для объекта, который будет использоваться в нескольких местах вашего кода, особенно в нескольких файлах или функциях. Также используйте, когда вы хотите, чтобы другие объекты запускались с этим базовым набором свойств, например, с интерфейсом Vehicle который несколько классов реализуют как конкретные типы транспортных средств, таких как Car, Truck, Boat (например, class Car implements Vehicle).
      </p>
      <p>
      <strong>Когда не использовать интерфейсы:</strong> Когда вы хотите иметь значения по умолчанию, реализации, конструкторы или функции (а не только подписи).
      </p>
      <p>
      <strong>Классы:</strong> также позволяют определять тип, который будет использоваться во время разработки, и время компиляции для строгой типизации и, кроме того, могут использоваться во время выполнения. Это также означает, что код не скомпилирован, поэтому он займет место. Это одно ключевое отличие, но оно имеет больше последствий, чем просто пространство. Это означает, что классы могут быть проверены на типизацию, сохраняя понимание того, "кто они" даже в переданном JS-коде. Дальнейшие различия включают в себя: классы могут быть созданы с использованием new и могут быть расширены, но не реализованы. Классы могут иметь конструкторы и фактический код функции наряду со значениями по умолчанию.
      </p>
      <p>
      <strong>Когда использовать классы:</strong> когда вы хотите создать объекты, в которых есть действительный код функции, есть конструктор для инициализации и/или вы хотите создавать их экземпляры с помощью new. Также для простых объектов данных вы можете использовать классы для установки значений по умолчанию. Другой раз, когда вы захотите их использовать, это когда вы выполняете проверку типов, хотя при необходимости есть обходные пути для интерфейсов (см. Раздел OS раздела link).
      </p>
      <p>
      <strong>Когда не использовать классы:</strong> когда у вас есть простой интерфейс данных, вам не нужно создавать его экземпляр, когда вы хотите, чтобы он был реализован другими объектами, когда вы хотите просто поместить интерфейс в существующий объект (файлы определения типов думать) или когда пространство, которое это займет, является запретительным или необоснованным. В качестве примечания, если вы посмотрите в файлах .d.ts, вы заметите, что они используют только интерфейсы и типы, и, таким образом, это полностью удаляется при передаче в TS.
      </p>
    `,
  },

  {
    id: 89,
    title: 'Какая разница между интерфейсом и абстрактным классом?',
    category: [QuizletQuestionCategoryEnum.typescript],
    level: 1,
    answer: `
      <p>
        <strong>Абстрактный класс</strong>  — это класс, у которого не реализован один или больше методов (некоторые языки требуют такие методы помечать специальными ключевыми словами).
      </p>
      <p>
        <strong>Интерфейс</strong>  — это абстрактный класс, у которого ни один метод не реализован, все они публичные и нет переменных класса.
      </p>
      <p>
        Интерфейс нужен обычно когда описывается только интерфейс (тавтология). Например, один класс хочет дать другому возможность доступа к некоторым своим методам, но не хочет себя «раскрывать». Поэтому он просто реализует интерфейс.
      </p>
      <p>
        Абстрактный класс нужен, когда нужно семейство классов, у которых есть много общего. Конечно, можно применить и интерфейс, но тогда нужно будет писать много идентичного кода.
      </p>
      <p>
        Можно считать, что любой интерфейс — это уже абстрактный класс, но не наоборот.
      </p>
      <p>
        Абстрактный класс — средство разработки классов на нижнем уровне, средство для повторного использования кода; интерфейс — средство выражения семантики класса. Таким образом, это совершенно разные, мало связанные между собой понятия.
      </p>
      <p>
        Абстрактный класс — это «заготовка» класса: реализовано большинство методов (включая внутренние), кроме нескольких. Эти несколько нереализованных методов вполне могут быть внутренними методами класса, они лишь уточняют детали имплементации. Абстрактный класс — средство для повторного использования кода, средство, чтобы указать, какой метод обязан быть перекрыт для завершения написания класса.
      </p>
      <p>
        Интерфейс же — это своего рода контракт: интерфейсы используются в определениях чтобы указать, что объект, который будет использован на самом деле, должен реализовывать (для входных параметров) или будет гарантированно реализовывать (для выходных параметров) набор методов и (что намного важнее!) иметь определённую семантику. Интерфейс вполне может быть и пустым, тем не менее, имплементировать интерфейс означает поддерживать данную семантику.
      </p>
    `,
  },

  {
    id: 90,
    title: 'Какая разница между интерфейсом и типом?',
    category: [QuizletQuestionCategoryEnum.typescript],
    level: 1,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://teletype.in/@alteregor/rkPlgmQz8',
      },
    ],
    answer: `
      <p>Сходства</p>
      <ul>
        <li>Интерфейсы и типы могут использоваться для описания структур данных</li>
        <li>Могут использоваться для типизации функции</li>
        <li>Интерфейсы и типы могут быть имплементированы классами</li>
        <li>Интерфейсы и типы позволяют выразить пересечение типов</li>
      </ul>
      <p>Отличия</p>
      <ul>
        <li>Одним из наиболее существенных функциональных отличий между type и interface является то, что, с type у нас может быть объединение нескольких других type - в данном случае это type PetType, который может быть либо IDog, либо ICat, то с interface, данная концепция не представляется возможной. Если мы попытаемся расширить в IPet тип объединения PetType, то увидим, что TypeScript “ругается” - An interface can only extend an object type or intersection of object types with statically known members.
          <br/>
          interface - это конкретный контракт и мы не можем иметь одно или другое. Он должен быть заблокирован при объявлении. Тоже самое касается class, реализующего один из этих типов объединения PetType. TypeScript будет “ругаться”, ведь class - это образец того, как создавать экземпляры объектов.
        </li>
        <li>Ещё одно функциональное различие между interface и type заключается в том, что если у нас два interface с одинаковыми именами, при использовании они будут объединены вместе. Мы получим доступ к свойствам a и b.</li>
        <li>Интерфейсы нельзя комбинировать с mapped типами (Required, Pick, Readonly, Partial и прочими). ЛИБО! Вначале сделать тип, а потом его extends</li>
        <li>Из-за того, что interface поддерживает declaration merging (может быть расширен в любом месте) его нельзя использовать там, где ожидается Record<string, any>. Это может быть проблемой в ситуациях, где нужно использовать URLSearchParams или другое браузерное API, ожидающее Record<string, any></li>
      </ul>
    `,
  },

  {
    id: 91,
    title: 'Что такое RxJS?',
    category: [QuizletQuestionCategoryEnum.rxjs],
    level: 1,
    answer: `
      <p>RxJs - это библиотека для реактивного программирования, которая позволит удобно организовать работу с событиями и асинхронным кодом, писать сложную логику декларативно.</p>
      <p>RxJs позволяет создавать паттерн обзёрвер, дополнительно с фильтрами и модификациями в виде Subject, merge потоков, их фильтрацией и обработкой</p>
      `,
  },

  {
    id: 92,
    title: 'Чем отличаются Observable и Subject?',
    category: [QuizletQuestionCategoryEnum.rxjs],
    level: 1,
    answer: `
      <p>Observable генерирует новые события для подписки внутри своего тела. Subject позволяет генерировать новые события вне своего тела.</p>
    `,
  },

  {
    id: 93,
    title: 'Какие бывают Subject?',
    category: [QuizletQuestionCategoryEnum.rxjs],
    level: 1,
    answer: `
      <p>Subject - обыкновенный</p>
      <p>BehaviorSubject — вариант Subject, который требует начального значения и имеет свойство хранить текущее значение. В случаях, если нам важно иметь начальное значение у подписок, то BehaviorSubject просто незаменим. Таким образом, подписка всегда будет иметь последнее (текущее) значение, с которым можно будет работать.</p>
      <p>ReplaySubject — еще один вид Subject, который также может отправлять старые значения новым подписчикам (количество последних может быть указано в скобках при создании), как и BehaviorSubject. Кроме этого, у него есть одна особенность — он может запоминать часть старых значений и отправлять их новым подписчикам. Создавая ReplaySubject, можно указать количество таковых значений. Например, новый пользователь добавился в чат, и мы хотим показать ему последнии сообщения. </p>
      <p>AsyncSubject — разновидность Subject, чья особенность заключается в том, что он передает только последнее значение всем своим подписчикам и только после завершения выполнения Observable subject.complete().  Используем тогда, когда нам нужно только последнее значение, при этом все остальные нам не важны. Пожалуй, самым подходящим вариантом использования AsyncSubject будет обработка HTTP-запроса, содержащего только один результат</p>
      `,
  },

  {
    id: 94,
    title:
      'Как сделать несколько последовательных запросов к API с помощью RxJS?',
    category: [QuizletQuestionCategoryEnum.rxjs],
    level: 1,
    links: [{ label: 'Habr', href: 'https://habr.com/ru/post/471572/' }],
    answer: `
    <p><strong>subscribe</strong></p>
    <p>Довольно простой способ. Делаем первый запрос к API. Затем, во вложенной подписке, чтобы можно было использовать первый ответ, делаем еще два запроса к API.</p>
    
    <p><strong>mergeMap</strong></p>
    <p>Этот оператор лучше всего использовать когда нам нужно вручную контролировать порядок запросов.
    Итак, когда мы используем mergeMap?
    Когда результат первого запроса к API нам нужен для того, чтобы сделать следующий.</p>

    <p><strong>forkJoin</strong></p>
    <p>Этот оператор подойдет, если нам нужно сделать несколько запросов и важен результат каждого. То есть можно сгруппировать несколько запросов, запустить их параллельно и вернуть только один observable.
    Итак, когда мы используем forkJoin?
    Когда запросы могут выполняться параллельно и не зависеть друг от друга.</p>
    `,
  },

  {
    id: 95,
    title: 'Как можно конфигурировать Angular-приложение?',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 1,
    answer: `
      <p>Через файлы environment, команды в package.json, angular.json позволит менять папки для стейджа и прода</p>
    `,
  },

  {
    id: 96,
    title: 'Для чего нужны environment-файлы? Когда их лучше не использовать?',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 1,
    answer: `
      <p>Environment файлы нужны дя франения статичной информации, которая отличается в зависимости от окружения, будь то stage, uat, prod, pred-prod, localhost и т.д.</p>
      <p>Желательно не использовать эти файлы для динамеческой информации, а также для хранения констант, не связанных с окружением</p>
      `,
  },

  {
    id: 97,
    title: 'В чем разница между умным (smart) и глупым (dumb) компонентами?',
    category: [QuizletQuestionCategoryEnum.frontend],
    level: 1,
    answer: `
      <p>Смысл в разделении ответственности. Глупые компоненты должны лишь отображать уже подготовленую информацию, имет стили и являться максимально мало-функциональными.</p>
      <p>Умные компоненты являются оберткой для одной или множества глупых компонент. Они берут на себя максимально больше вычислительных инструментов и нужны для предоставления глупым компонентам максимально просчитанной информации</p>
      `,
  },

  {
    id: 98,
    title:
      'В чем разница между NgForm, FormGroup и FormControl и как они применяются для построения форм?',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 1,
    answer: `
      <p><strong>ngForm</strong> - это директива, которая позволяет сгруппировать темплейт-форму. Также это интерфейс, который при отправки формы будет выдаваться как эвент</p>
      <p><strong>FormGroup</strong> - группировка контролов в реактивных формах в виде объекта</p>
      <p><strong>FormArray</strong> - группировка контролов в реактивных формах в виде массива</p>
      <p><strong>FormControl</strong> - единичный контрол формы</p>
      <p>Все они содержат информацию о фокусе, валидации, подписки и др.</p>
      `,
  },

  {
    id: 99,
    title: 'Зачем нужен и как работает async pipe?',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 1,
    answer: `
      <p>Одним из встроенных классов, который в отличие от других pipes уже по умолчанию представляет тип impure. AsyncPipe позволяет получить результат асинхронной операции.</p>

      <p>AsyncPipe отслеживает объекты Observable и Promise и возвращает полученное из этих объектов значение. При получении значения AsyncPipe сигнализирует компоненту о том, что надо проверить изменения. Если компонент уничтожается, то AsyncPipe автоматически отписывается от объектов Observable и Promise, что дезавуирует возможные утечки памяти.</p>
      `,
  },

  {
    id: 100,
    title: 'В чем разница межэу функциональными и классовыми компонентами?',
    category: [QuizletQuestionCategoryEnum.react],
    level: 1,
    answer: `
      <p>Практически никакой. И там и там можно следить за состоянием, реагировать на уровнях жизненного цикла компонент</p>
      <p>Отличия в подходе. Классовые компоненты - это ООП, явные методы жизненного цикла, строгие правила</p>
      <p>Функциональные компоненты - это ФП и хуки, проще читаемость кода</p>
      <p> Пока не существует хуков, реализующих методы жизненного цикла getSnapshotBeforeUpdate, getDerivedStateFromError и componentDidCatch</p>
      <p>Еще в классовых компонентах нельзя сделать Error Boundaries:
        <code>
          class ErrorBoundary extends Component { ...<br/>
          <br/>
          componentDidCatch(error) { <br/>
            this.setState({hasError: true});  <br/>
          }  <br/>
          <br/>
          ...<br/>
          ErrorBoundary <br/>
            ChildComponent users={this.state.users} <br/>
          /ErrorBoundary
        </code>
      </p>
      `,
  },

  {
    id: 101,
    title:
      'Какие данные лучше хранить в состоянии компонента, а какие передавать через пропсы?',
    category: [QuizletQuestionCategoryEnum.react],
    level: 1,
    answer: `
      <p>В зависимости от ситуации. Как правило, в состоянии компонента лучше хранить те данные, с которыми работает конкретно этот компонент и за которое он ответственен</p>
      <p>Через пропсы передавать уже подготовленные данные например от контейнерной компоненты до глупой. Либо если идет связь один - много, чтобы не делать лишних вычислений</p>
      `,
  },

  {
    id: 102,
    title: 'Минусы и плюсы хуков?',
    category: [QuizletQuestionCategoryEnum.react],
    level: 1,
    answer: `
      <p>Хуки дают новый мощный способ повторного использования кода в компонентах. В классах были HOC, однако они вызывали ад оберток.</p>
      <p> Пока не существует хуков, реализующих методы жизненного цикла getSnapshotBeforeUpdate, getDerivedStateFromError и componentDidCatch</p>
      `,
  },

  {
    id: 103,
    title: 'Какими могут быть свои кастомные хуки?',
    category: [QuizletQuestionCategoryEnum.react],
    level: 1,
    toBeReviewed: true,
    answer: `
      <p>Создание пользовательских хуков позволяет вам перенести логику компонентов в функции, которые можно повторно использовать.</p>
      <p>Пользовательский хук — это JavaScript-функция, имя которой начинается с «use», и которая может вызывать другие хуки. Например, функция useFriendStatus ниже — это наш первый пользовательский хук</p>
      `,
  },

  {
    id: 104,
    title: 'Что такое фрагменты?',
    category: [QuizletQuestionCategoryEnum.react],
    level: 1,
    links: [
      {
        label: 'React official',
        href: 'https://ru.reactjs.org/docs/fragments.html',
      },
    ],
    answer: `
      <p>Фрагмент - это "пустой" тег либо React.Fragment. Из-за структуры реакта, требуется чтобы возвращался 1 элемент (с род-доч связями), а не массив из них. Чтобы не создавать лишний div тег, можно просто использовать фрагмент</p>
      `,
  },

  {
    id: 105,
    title: 'Что такое порталы?',
    category: [QuizletQuestionCategoryEnum.react],
    level: 1,
    links: [
      {
        label: 'React official',
        href: 'https://ru.reactjs.org/docs/portals.html',
      },
    ],
    answer: `
      <p>Порталы позволяют рендерить дочерние элементы в DOM-узел, который находится вне DOM-иерархии родительского компонента.</p>
      <p>Как правило используется для модалок, менюшек и других "всплывающих" элементов, которых не красиво хранить как дочерний элемент<p>
      `,
  },

  {
    id: 106,
    title: 'Что такое рефы?',
    category: [QuizletQuestionCategoryEnum.react],
    level: 1,
    links: [
      {
        label: 'React official',
        href: 'https://ru.reactjs.org/docs/refs-and-the-dom.html',
      },
    ],
    answer: `
      <p>Могут возникать ситуации, когда вам требуется императивно изменить дочерний элемент, обойдя обычный поток данных. Подлежащий изменениям дочерний элемент может быть как React-компонентом, так и DOM-элементом. <p>
      <p>Ситуации, в&nbsp;которых использование рефов является оправданным:</p>
      <ul>
        <li>Управление фокусом, выделение текста или воспроизведение медиа.</li>
        <li>Императивный вызов анимаций.</li>
        <li>Интеграция со&nbsp;сторонними DOM-библиотеками.</li>
      </ul>
      <p>
        <code>
          const textInput = useRef(null); <br/>
          <br/>
          function handleClick() {<br/>
            textInput.current.focus();<br/>
          }
        </code>
      </p>
      `,
  },

  {
    id: 107,
    title: 'Жизненный цикл компонент?',
    category: [QuizletQuestionCategoryEnum.react],
    level: 1,
    toBeReviewed: true,
    links: [
      {
        label: 'w3s',
        href: 'https://www.w3schools.com/react/react_lifecycle.asp',
      },
    ],
    answer: `
      <h2>Mounting</h2>
      <p>Mounting means putting elements into the DOM.</p>
      <p>React has four built-in methods that gets called, in this order, when 
      mounting a component:</p>
      <ol>
        <li><code>constructor()</code></li>
        <li><code>getDerivedStateFromProps()</code></li>
        <li><code>render()</code></li>
        <li><code>componentDidMount()</code></li>
      </ol>

      <br/>

      <h2>Updating</h2>
      <p>The next phase in the lifecycle is when a component is <em>updated</em>.</p>
      <p>A component is updated whenever there is a change in the component's
      <code class="w3-codespan">state</code> or <code class="w3-codespan">props</code>.</p>
      <p>React has five built-in methods that gets called, in this order, when a component 
      is updated:</p>
      <ol>
        <li><code>getDerivedStateFromProps()</code></li>
        <li><code>shouldComponentUpdate()</code></li>
        <li><code>render()</code></li>
        <li><code>getSnapshotBeforeUpdate()</code></li>
        <li><code>componentDidUpdate()</code></li>
      </ol>

      <br/>

      <h2>Unmounting</h2>
      <p>The next phase in the lifecycle is when a component is removed from the DOM, or <em>unmounting</em> as React likes to call it.</p>
      <p>React has only one built-in method that gets called when a component is unmounted:</p>
      <ul>
        <li><code>componentWillUnmount()</code></li>
      </ul>
      `,
  },

  {
    id: 108,
    title:
      'В каком методе жизненного цикла компонента лучше делать запросы на сервер? Почему?',
    category: [QuizletQuestionCategoryEnum.react],
    level: 1,
    toBeReviewed: true,
    answer: `
      <p>В componentDidMount(), если не будет меняться входная информация через пропс, которая нужна для обраотки запроса.
      Либо componentDidUpdate(), если нужно обновлять запрос при обновлении пропсов</p>
      `,
  },

  {
    id: 109,
    title:
      'В каком методе жизненного цикла компонента лучше производить подписку и отписку от листенера? Почему? Зачем отписываться?',
    category: [QuizletQuestionCategoryEnum.react],
    level: 1,
    toBeReviewed: true,
    answer: `
      <p>Подписку в componentDidMount(), отписку в componentWillUnmount(). Если не сделать отписку, то велика вероятность получить мемори лик, особенно если несколько компонентов и постоянные обновления</p>
      `,
  },

  {
    id: 110,
    title: 'Что такое контекст и где его использовать?',
    category: [QuizletQuestionCategoryEnum.react],
    level: 1,
    links: [
      {
        label: 'React official',
        href: 'https://ru.reactjs.org/docs/context.html',
      },
    ],
    answer: `
      <p>Контекст позволяет передавать данные через дерево компонентов без необходимости передавать пропсы на промежуточных уровнях.</p>
      <p>Контекст разработан для передачи данных, которые можно назвать «глобальными» для всего дерева React-компонентов (например, текущий аутентифицированный пользователь, UI-тема или выбранный язык). </p>
      <p>Когда наше приложение достаточно большое, и мы не хотим прокидывать пропсы через огромную цепочку дочерних компонентов, которые не используют данный стейт. В других случаях лучше использовать props </p>
      <ul>
        <li>статические глобальные переменные </li>
        <li>смена темы </li>
        <li>смена локали </li>
        <li>авторизация </li>
      </ul>
      <p>Контекст не оптимизирован для частых обновлений. Хранимые данные в контексте не должны меняться каждую секунду. </p>
      <p>Для всего остального (да и для этого тоже) использовать лучше Redux. </p>
      `,
  },

  {
    id: 111,
    title: 'В чем особенность PureComponent и React.memo?',
    category: [QuizletQuestionCategoryEnum.react],
    level: 1,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://habr.com/ru/company/redmadrobot/blog/318222/',
      },
    ],
    answer: `
      <p>PureComponent (React.memo для функциональных) изменяет lifecycle-метод shouldComponentUpdate, автоматически проверяя, нужно ли заново отрисовывать компонент. При этом PureComponent будет вызывать рендер только если обнаружит изменения в state или props компонента, а значит во многих компонентах можно менять state без необходимости постоянно писать</p>
      <p>Сам же ререндер как правило тригерится из родительской цепочки</p>
      <p>Использование shallowEqual говорит о том, что происходит неглубокая проверка params и state, так что сравнение не будет происходить по глубоко вложенным объектам, массивам.</p>
      <p>Глубокое сравнение — очень затратная операция. Если бы PureComponent каждый раз ее вызывал, то он бы приносил больше вреда, чем пользы. Никто не мешает использовать проверенный shouldComponentUpdate, чтобы вручную определить необходимость нового рендера. Самый простой вариант — прямое сравнение параметров.</p>
      <code>class MyComponent extends PureComponent {…} </code>
      <code>const MyComponent = React.memo(…) </code>
      `,
  },

  {
    id: 112,
    title: 'Что такое мемоизированные селекторы?',
    category: [QuizletQuestionCategoryEnum.react],
    level: 1,
    answer: `
      <p>Мемоизированные селекторы - это например библиотека реакт-реселект. Это такие чистые функции, которые вычисляют какие-либо данные на основе получаемых аргументов и запоминают результат. Если произойдет повторное обращение, то функция возьмет кешированный результат из памяти.</p>
      `,
  },

  {
    id: 113,
    title: 'В чем видите преимущества библиотеки React?',
    category: [QuizletQuestionCategoryEnum.react],
    level: 1,
    answer: `
      <p>Скорость разработки, свобода действий по сравнению с другими фреймворками</p>
      `,
  },

  {
    id: 114,
    title: 'Что такое Virtual DOM?',
    category: [QuizletQuestionCategoryEnum.react],
    level: 1,
    links: [
      {
        label: 'React official',
        href: 'https://ru.reactjs.org/docs/faq-internals.html',
      },
      {
        label: 'Ссылка 2',
        href: 'https://habr.com/ru/company/macloud/blog/558682/',
      },
    ],
    answer: `
      <p>DOM расшифровывается как Document Object Model (объектная модель документа). Проще говоря, DOM — это представление пользовательского интерфейса (user interface, UI) в приложении. При каждом изменении UI, DOM также обновляется для отображения этих изменений. Частые манипуляции с DOM негативно влияют на производительность.</p>
      <p>Виртуальный DOM (VDOM) — это концепция программирования, в которой идеальное или «виртуальное» представление пользовательского интерфейса хранится в памяти и синхронизируется с «настоящим» DOM при помощи библиотеки, такой как ReactDOM.</p>
      `,
  },

  {
    id: 115,
    title: 'Зачем в списках ключи?',
    category: [QuizletQuestionCategoryEnum.react],
    level: 1,
    links: [
      {
        label: 'React official',
        href: 'https://ru.reactjs.org/docs/lists-and-keys.html',
      },
    ],
    answer: `
      <p>Ключи помогают React определять, какие элементы были изменены, добавлены или удалены. Их необходимо указывать, чтобы React мог сопоставлять элементы массива с течением времени</p>
      <p>Лучший способ выбрать ключ — это использовать строку, которая будет явно отличать элемент списка от его соседей. Чаще всего вы будете использовать ID из ваших данных как ключи</p>
      <p>Мы не рекомендуем использовать индексы как ключи, если порядок элементов может поменяться. Это негативно скажется на производительности и может вызвать проблемы с состоянием компонента. </p>
      `,
  },

  {
    id: 116,
    title: 'В чем основная идея Redux?',
    category: [QuizletQuestionCategoryEnum.redux],
    level: 1,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://stepansuvorov.com/blog/2017/05/learn-redux/#:~:text=%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D0%B0%D1%8F%20%D0%B8%D0%B4%D0%B5%D1%8F%20Redux%20%E2%80%93%20%D0%B2%D1%81%D0%B5%D0%B3%D0%B4%D0%B0%20%D0%B8%D0%BC%D0%B5%D1%82%D1%8C,%D1%87%D1%82%D0%BE%20%D1%82%D0%BE%D0%B6%D0%B5%20%D1%8F%D0%B2%D0%BB%D1%8F%D0%B5%D1%82%D1%81%D1%8F%20Javascript%20%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%BC.',
      },
    ],
    answer: `
      <p>Основная идея Redux – всегда иметь единственное состояние приложения. Это состояние представляет из себя Javascript объект – Redux Store, который доступен только для чтения. Если вы хотите изменить состояние, то вам нужно породить Action, что тоже является Javascript объектом.</p>
      <p>Редакт также использует flux архитектуру, которая является one-way-data-flow. Означает что все данные доступны только для чтения, а если мы хотим их поменять, то используем специальные функции, которые задействую смену стейта и обновят компонент-подпискиков на эти данные</p>
      `,
  },

  {
    id: 117,
    title: 'Работа со стилями в React',
    category: [QuizletQuestionCategoryEnum.react],
    level: 1,
    links: [
      {
        label: 'Medium',
        href: 'https://medium.com/@stasonmars/%D1%80%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE-%D0%BF%D0%BE-%D1%82%D1%80%D1%91%D0%BC-%D1%81%D0%BF%D0%BE%D1%81%D0%BE%D0%B1%D0%B0%D0%BC-%D1%81%D1%82%D0%B8%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-%D0%B2-react-2ca5c0c7464b',
      },
    ],
    answer: `
      <ul>
        <li>Глобальные файли стилей импортируемые внутри компоненты</li>
        <li>Инлайновые через style</li>
        <li>Модульные стили через именование файла .module (можно только классы)</li>
        <li>Styled components</li>
      </ul>
      `,
  },

  {
    id: 118,
    title:
      'React — это библиотека или фреймворк? Какая разница между этими двумя понятиями.',
    category: [QuizletQuestionCategoryEnum.react],
    level: 1,
    answer: `
      <p>
      Фреймворк - это набор библиотек и инструментов. Библиотека - это просто программный модуль на определенном языке. React - библиотека
      </p>
      `,
  },

  {
    id: 119,
    title: 'Можно ли использовать jQuery вместе с React? Почему да/нет?',
    category: [QuizletQuestionCategoryEnum.react],
    level: 1,
    answer: `
      <p>
      Крайне не рекомендуется использовать jQuery с реактом. Обе библиотеки взаимодействуют с ДОМ. При этом, у каждой разный принцип взаимодействия: напрямую и виртуальный ДОМ. Они будут друг другу мешать 
      </p>
      `,
  },

  {
    id: 120,
    title: 'Перечислите все библиотеки, которые использовались в связи с React',
    category: [QuizletQuestionCategoryEnum.react],
    level: 1,
    answer: `
      <p>
        Router, Redux (thunk, saga), axios, jest, testing-library, momentjs, lodash
      </p>
      `,
  },

  {
    id: 121,
    title: 'Расскажите о пирамиде тестирования',
    category: [QuizletQuestionCategoryEnum.common],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://dou.ua/lenta/columns/testing-in-jiji/',
      },
    ],
    answer: `
    <p>Понятие пирамиды тестирования широко известно. Ее&nbsp;задача&nbsp;— сгруппировать тесты по&nbsp;разным уровням детализации. </p>
    <h3>Первый уровень: unit-тесты</h3>
    <p>В&nbsp;основе пирамиды лежат маленькие, дешевые и&nbsp;быстрые unit-тесты. За&nbsp;их&nbsp;написание и&nbsp;поддержку отвечает команда разработчиков. Весь старый и&nbsp;новый функционал должен быть подкреплен unit-тестами. Именно с&nbsp;их&nbsp;помощью можно быстро и&nbsp;комплексно проверить стабильность приложения. </p>
    <p>Чем выше мы&nbsp;будем подниматься по&nbsp;пирамиде, тем выше комплексность, цена и&nbsp;хрупкость тестов. Это важно понимать, чтобы сэкономить деньги и&nbsp;время, которое компания выделяет на&nbsp;разработку.</p>
    <h3>Второй уровень: интеграционные тесты</h3>
    <p>Суть этого процесса в&nbsp;объединении программных модулей в&nbsp;группы и&nbsp;их&nbsp;последующее тестирование. Проще говоря, это проверка бизнес-логики без использования UI. На&nbsp;проекте интеграционные тесты пишут разработчики и&nbsp;они&nbsp;же их&nbsp;и&nbsp;поддерживают. Однако можно встретить команды, где этот уровень закрывает QA. В&nbsp;этом нет ничего плохого&nbsp;— если человек компетентен и&nbsp;может выполнять подобную работу качественно, то&nbsp;ему стоит это делать.</p>
    <h3>Третий уровень: тесты пользовательского функционала</h3>
    <p>Здесь количество тестов должно быть наименьшим. Воссоздавая пользовательские сценарии, мы&nbsp;проверяем приложения на&nbsp;стабильность и&nbsp;работоспособность. На&nbsp;этом уровне тесты самые хрупкие. Да, технологии шагнули вперед, скорость выполнения UI-тестов возросла вместе со&nbsp;стабильностью, однако не&nbsp;ждите постоянно зеленых билдов&nbsp;— flaky-тесты все еще существуют.</p>
      `,
  },

  {
    id: 122,
    title: 'Типы автотестов',
    category: [QuizletQuestionCategoryEnum.common],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://logrocon.ru/news/automation_testing',
      },
    ],
    answer: `
    <ul> 
      <li><strong>Смоук тестирование</strong> - выполняются каждый раз, когда мы получаем новый билд (версию), проекта (системы) на тестирование, при этом считая её относительно нестабильной. Нам нужно убедиться что критически важные функции AUT (Application Under Test) работают согласно ожиданиям. Идея данного вида тестирования заключается в том, чтобы выявить серьёзные проблемы как можно раньше, и отклонить этот билд (вернуть на доработку) на раннем этапе тестирования, чтобы не углубляться в долгие и сложные тесты, не затрачивая тем самым время на заведомо бракованное ПО.</li> 
      <li><strong>Модульное тестирование</strong> - юнит тесты, это тип тестирования программного обеспечения, при котором тестируются отдельные модули или компоненты программного обеспечения. Его цель заключается в том, чтобы проверить, что каждая единица программного кода работает должным образом. </li> 
      <li><strong>Интеграционное тестирование</strong> - это тип тестирования, при котором программные модули объединяются логически и тестируются как группа</li> 
      <li><strong>Функциональное тестирование</strong> - это тестирование ПО в целях проверки реализуемости функциональных требований, то есть способности ПО в определённых условиях решать задачи, нужные пользователям. Функциональные требования определяют, что именно делает ПО, какие задачи оно решает. </li> 
      <li><strong>Проверка ключевых слов</strong> </li>
      <li><strong>Регрессионное тестирование</strong> - когда нужно убедиться что новые (добавленные) функции приложения / исправленные дефекты не оказали влияния на текущую, уже существующую функциональность, работавшую (и протестированную) ранее.</li>
      <li><strong>Тестирование на основе данных</strong> - Управляемое данными тестирование – это создание тестовых сценариев, в которых тестовые данные и / или выходные значения считываются из файлов данных вместо использования одних и тех же жестко закодированных значений при каждом запуске теста. Таким образом, тестеры могут проверить, как приложение эффективно обрабатывает различные входные данные.</li> 
      <li><strong>Тестирование черного ящика</strong> - Тестирование чёрного ящика или поведенческое тестирование — стратегия тестирования функционального поведения объекта с точки зрения внешнего мира, при котором не используется знание о внутреннем устройстве тестируемого объекта.</li> 
    </ul>
     `,
  },

  {
    id: 123,
    title:
      'Что такое unit-тесты? Какое место в пирамиде тестирования занимают unit-тесты?',
    category: [QuizletQuestionCategoryEnum.common],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://dou.ua/lenta/columns/testing-in-jiji/',
      },
    ],
    answer: `
    <p>Юнит-тесты, это самое основание пирамиды. Эти тесты маленькие, дешевые и их очень много.</p>
    <p>В&nbsp;основе пирамиды лежат маленькие, дешевые и&nbsp;быстрые unit-тесты. За&nbsp;их&nbsp;написание и&nbsp;поддержку отвечает команда разработчиков. Весь старый и&nbsp;новый функционал должен быть подкреплен unit-тестами. Именно с&nbsp;их&nbsp;помощью можно быстро и&nbsp;комплексно проверить стабильность приложения. </p>
     `,
  },

  {
    id: 124,
    title:
      'Что такое code coverage? Обязательно ли 100% покрытие тестами кода?',
    category: [QuizletQuestionCategoryEnum.common],
    level: 2,
    answer: `
    <p>Покрытие кода тестами. Не обязательно, но к этому надо стремиться</p>
     `,
  },

  {
    id: 125,
    title: 'Как запретить браузеру отдавать кэш на HTTP-запрос?',
    category: [QuizletQuestionCategoryEnum.common],
    level: 2,
    links: [
      {
        label: 'MDN',
        href: 'https://developer.mozilla.org/ru/docs/Web/HTTP/Caching',
      },
      {
        label: 'Ссылка 2',
        href: 'https://qna.habr.com/q/258883',
      },
    ],
    answer: `
    <p>Производительность веб-сайтов и приложений можно значительно повысить за счёт повторного использования ранее полученных ресурсов. Веб-кеши сокращают задержку и снижают сетевой трафик, уменьшая тем самым время, необходимое для отображения ресурсов. Используя HTTP-кеширование, сайты становятся более отзывчивыми.</p>
    <p>Отключить кеш на страничках</p>
    <p>
    <code>
      Теги с директивами "не кешировать" для браузера и "узлов" веб-сети
      meta http-equiv="cache-control" content="no-cache, no-store, must-revalidate"
      meta http-equiv="pragma" content="no-cache"
      meta http-equiv="expires" content="0"

      динамическое назначение версии статичному контенту - стили и скрипты js
      link rel="stylesheet" href="css/style.css?fdhdfhfhdfh"
      script src="js/bandle.js?sdvsdv"
    </code>
    </p>
    `,
  },

  {
    id: 126,
    title: 'Что такое XSS (Cross-Site Scripting)?',
    category: [QuizletQuestionCategoryEnum.common],
    level: 2,
    answer: `
      <p><strong>XSS (англ. Cross-Site Scripting — «межсайтовый скриптинг»)</strong> — довольно распространенная уязвимость, которую можно обнаружить на множестве веб-приложений. Ее суть довольно проста, злоумышленнику удается внедрить на страницу JavaScript-код, который не был предусмотрен разработчиками. Этот код будет выполняться каждый раз, когда жертвы (обычные пользователи) будут заходить на страницу приложения, куда этот код был добавлен.</p>
      <p>Например, можно добавить JavaScript-код в поле ввода, текст из которого сохраняется и в дальнейшем отображается на странице для всех пользователей. Это может быть поле для ввода информации о себе на странице профиля социальной сети или комментарии на форуме.</p>
      <p>Спастись от этого можно путем чистки всех входных данных от пользователя, чистить спецсимволы и не позволять добавлять скрипты в БД</p>
      `,
  },

  {
    id: 127,
    title: 'Расскажите о паттернах Observer, Pub/Sub и где они используются',
    category: [QuizletQuestionCategoryEnum.common],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://habr.com/ru/post/270339/',
      },
    ],
    answer: `
      <p><strong>Observer</strong> представляет собой не что иное, как связь один-ко-многим. В упрощенном виде этот паттерн состоит из объекта наблюдения (subject) и наблюдателей (observers).</p>
      <p><strong>Pub-sub</strong> паттерн является одной из вариаций паттерна Observer. Исходя из названия в паттерне выделяют два компонента Publisher (издатель) и Subscriber (подписчик). В отличие от Observer, связь между объектами осуществляется посредством канала связи Event Channel (шины событий).</p>
      <p>Publisher кидает свои события в Event Channel, а Subscriber подписывается на нужное событие и слушает его на шине, что обеспечивает отсутствие прямой связи между подписчиком и издателем.</p>
      <p>Примеры использования: чаты, обзерверы браузера (Resize Observer, IntersectionObserver, MutationObserver)</p>
      `,
  },

  {
    id: 128,
    title:
      "С какой целью может быть использован self.addEventListener('fetch', event => {})?",
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://habr.com/ru/post/517672/',
      },
      {
        label: 'Ссылка 2',
        href: 'https://developer.mozilla.org/ru/docs/Web/API/Service_Worker_API/Using_Service_Workers',
      },
    ],
    answer: `
      <p>Это сервис воркер</p>
      <p>Одной из важнейших проблем, от которой страдали пользователи веб-приложений, была работа в условиях потери связи. Лучшее в мире веб-приложение оставит ужасное впечатление от использования, если вы не сможете его загрузить.</p>
      <p> Используя Service Worker, вы можете без труда получить приложение, использующее в первую очередь кешированные ресурсы, предоставляя тем самым поведение по умолчанию в автономном режиме, до того как будет получено по сети больше данных</p>
      <p>Событие fetch возникает каждый раз, когда запрашиваются любые подконтрольные сервис-воркеру ресурсы, к которым относятся документы из области видимости и другие ресурсы, связанные с этими документами (например, если в index.html происходит кросс-доменный запрос для загрузки изображения, то он тоже попадёт в сервис-воркер).</p>
      <p>Вы можете подключить к сервис-воркеру обработчик события fetch и внутри него на объекте события вызвать метод respondWith(), чтобы заменить ответы и показать собственную "магию".</p>
      `,
  },

  {
    id: 129,
    title: 'Что такое Event loop и как он работает?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 2,
    links: [
      {
        label: 'MDN',
        href: 'https://developer.mozilla.org/ru/docs/Web/JavaScript/EventLoop',
      },
      {
        label: 'Learn Javascript',
        href: 'https://learn.javascript.ru/event-loop',
      },
      {
        label: 'Ссылка 3',
        href: 'https://highload.today/kak-ustroen-event-loop-v-javascript-parallelnaya-model-i-tsikl-sobytij/',
      },
    ],
    answer: `
      <p>Параллелизм/Многопоточность в JavaScript работает за счёт цикла событий (event loop), который отвечает за выполнение кода, сбора и обработки событий и выполнения под-задач из очереди (queued sub-tasks). </p>
      <ul>
        <li>JavaScript бездействует и ждет свою задачу.</li>
        <li>Как только задачи появляются, движок начинает их выполнение, начиная с первой поступившей.</li>
        <li>Если поступила новая задача, но движок занят выполнением предыдущей — она ставится в очередь.</li>
      </ul>

      <p>Составляющие цикла событий</p>
      <ul>
        <li><strong>Stack (Стек).</strong> Представляет собой поток выполнения кода JavaScript. Event Loop выполняет одну простую задачу — осуществляет контроль стека вызовов и очереди обратных вызовов. Если стек вызовов пуст, цикл событий возьмет первое событие из очереди и отправит его в стек вызовов, который его запустит. При вызове нового метода вверху стека выделяется отдельный блок памяти. Стек вызовов отвечает за отслеживание всех операций в очереди, которые должны быть выполнены. При завершении очереди она извлекается из стека.</li>
        <li><strong>Heap (Куча).</strong> В куче происходит создание нового объекта. </li>
        <li><strong>Queue (Очередь).</strong> Очередь событий отвечает за отправку новых функций на трек обработки. Он следует структуре данных очереди, чтобы поддерживать правильную последовательность, в которой все операции должны отправляться на выполнение. Если проще, то это и есть список задач, которые должны отправиться на обработку и ждут своего часа.</li>
        <li><strong>Web API.</strong> Не являются частью JavaScript, они скорее созданы на основе JS. Каждый раз, когда вызывается асинхронная функция, она отправляется в API браузера. На основе команды, полученной из стека вызовов, API запускает собственную однопоточную операцию</li>
      </ul>

      <p>Операция отправляется в очередь событий. Следовательно, у нас есть циклическая схема для выполнения асинхронных операций в JavaScript. Сам язык является однопоточным, но API-интерфейсы браузера действуют как отдельные потоки.</p>
      <p>Цикл событий постоянно проверяет, пуст ли стек вызовов. Если он пуст, новые функции добавляются из очереди событий. Если это не так, то выполняется текущий вызов функции.</p>
      `,
  },

  {
    id: 130,
    title: 'Расскажите о микрозадачах и макрозадачах.',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 2,
    links: [
      {
        label: 'Learn Javascript',
        href: 'https://learn.javascript.ru/event-loop',
      },
    ],
    toBeReviewed: true,
    answer: `
      <p>Помимо макрозадач, описанных в этой части, существуют микрозадачи, упомянутые в главе Микрозадачи.</p>
      <p>Микрозадачи приходят только из кода. Обычно они создаются промисами: выполнение обработчика .then/catch/finally становится микрозадачей. Микрозадачи также используются «под капотом» await, т.к. это форма обработки промиса.</p>
      <p>Сразу после каждой макрозадачи движок исполняет все задачи из очереди микрозадач перед тем, как выполнить следующую макрозадачу или отобразить изменения на странице, или сделать что-то ещё.</p>
      <code>
      setTimeout(() => alert("timeout"));<br/>
      <br/>
      Promise.resolve()<br/>
        .then(() => alert("promise"));<br/>
        <br/>
      alert("code");
      </code>
      <p>Какой здесь будет порядок?</p>
      <ol>
        <li>code появляется первым, т.к. это обычный синхронный вызов.</li>
        <li>promise появляется вторым, потому что .then проходит через очередь микрозадач и выполняется после текущего синхронного кода.</li>
        <li>timeout появляется последним, потому что это макрозадача.</li>
      </ol>
      <p>Все микрозадачи завершаются до обработки каких-либо событий или рендеринга, или перехода к другой макрозадаче.</p>
      <p>Если мы хотим запустить функцию асинхронно (после текущего кода), но до отображения изменений и до новых событий, то можем запланировать это через queueMicrotask.</p>
      `,
  },

  {
    id: 131,
    title: 'Что такое Temporal Dead Zone?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://jsinthebits.com/what-is-the-temporal-dead-zone-e41369d4/#:~:text=%D0%9E%D0%B1%D1%8A%D1%8F%D1%81%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%20Temporal%20Dead%20Zone,%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8%20%D0%B4%D0%BE%20%D0%BC%D0%BE%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%20%D0%B8%D1%85%20%D0%BE%D0%B1%D1%8A%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F.',
      },
    ],
    answer: `
      <p>Вот что такое TDZ: термин для описания состояния, когда переменные недоступны. Они находятся в области видимости, но не объявлены.</p>
      <p>Переменные let и const существуют в TDZ с начала их объемлющей области видимости до момента их объявления.</p>
      <code>
      {
        // This is the temporal dead zone for the age variable!<br/>
        // This is the temporal dead zone for the age variable!<br/>
        // This is the temporal dead zone for the age variable!<br/>
        // This is the temporal dead zone for the age variable!<br/>
        let age = 25; // Whew, we got there! No more TDZ<br/>
        console.log(age);
      }
      </code>
      `,
  },

  {
    id: 132,
    title: 'Как работает Boxind и Unboxing?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://javascript.plainenglish.io/javascript-boxing-wrappers-5b5ff9e5f6ab',
      },
    ],
    answer: `
      <p><strong>Boxing</strong> - это автоматический процес заврачивания примитива в объект (new Boolean()) при присвоении нового значения-примитива. Именно поэтому мы можем использовать методы примитива такие как toString, toNumber и прочие</p>
      <p>При этом самостоятельно оборачивать в такй объект нерекомендуется, поскольку при проверке типа будет не примитив, а object</p>
      <p><strong>Unboxing</strong> - это автоматический процесс разворачивания примитива из его объектной обертки в тот момет, когда мы пытаеся взять его значение. Под капотом вызывается метод valueOf</p>
      `,
  },

  {
    id: 133,
    title: 'В чем разница между оператором in и методом hasOwnProperty?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 2,
    links: [
      {
        label: 'MDN 1',
        href: 'https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/in',
      },
      {
        label: 'MDN 2',
        href: 'https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty',
      },
    ],
    answer: `
      <p><strong>in</strong> - Смотрит, есть ли такое свойство у объекта, в том числе и то, что унаследовано от прототипа</p>
      <p><strong>hasOwnProperty</strong> - Смотрит, есть ли такое свойство у объекта, НО НЕ ОТ ПОТОТИПА</p>
    `,
  },

  {
    id: 134,
    title:
      'Опишите, с помощью чего в JS реализуются такие ООП-парадигмы как инкапсуляция, полиморфизм, абстракция?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://frontend-stuff.com/blog/object-oriented-programming/',
      },
    ],
    answer: `
      <h3>Инкапсуляция</h3>
      <p>Инкапсуляция включает в себя идею о том, что данные объекта не должны быть напрямую доступны. Нужно вызывать методы вместо прямого доступа к данным. Инкапсуляция позволяет нам скрывать/показывать свойства функций.</p>
      <p>Добиться инкапсуляции можно посредством использования приватных свойств в классах, геттеров и сеттеров, замыкания</p>
      <h3>Абстракция</h3>
      <p>Абстракция - это способ создания простой модели, которая содержит только важные свойства с точки зрения контекста приложения, из более сложной модели. Иными словами - это способ скрыть детали реализации и показать пользователям только функциональность. Абстракция игнорирует нерелевантные детали и показывает только необходимые. Важно помнить, что мы не можем создать экземпляр абстрактного класса.</p>
      <h3>Полиморфизм</h3>
      <p>Полиморфизмом является одним из принципов объектно-ориентированного программирования (ООП). Это помогает проектировать объекты таким образом, чтобы они могли совместно использовать или переопределять любое поведение с конкретными предоставленными объектами. </p>
      <p>Само слово означает много форм. Существует много толкований того, что именно оно означает, но идея заключается в способности вызывать один и тот же метод для разных объектов, и при этом каждый объект реагирует по-своему.</p>
      <h3>Наследование</h3>
      <p>Наследование - это механизм базирования объекта или class на другом объекте (наследование на основе прототипа) или class (наследование на основе класса). Мы избегаем необходимости переписывать один и тот же код, а также экономим пространство памяти, используя общие методы. Через классы это делается посредством метода extends. Также можно использовать цепочку прототипов</p>
    `,
  },

  {
    id: 135,
    title:
      'Что такое прототип? Как работает прототипное подражание в JS? +практическое',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 2,
    links: [
      {
        label: 'Learn Javascript 1 (общее)',
        href: 'https://learn.javascript.ru/prototype-inheritance',
      },
      {
        label: 'Learn Javascript 2 (про prototype)',
        href: 'https://learn.javascript.ru/prototype-inheritance',
      },
    ],
    answer: `
      <p>В JavaScript объекты имеют специальное скрытое свойство [[Prototype]] (так оно названо в спецификации), которое либо равно null, либо ссылается на другой объект. Этот объект называется «прототип»</p>
      <p>Прототип даёт нам немного «магии». Когда мы хотим прочитать свойство из object, а оно отсутствует, JavaScript автоматически берёт его из прототипа. В программировании такой механизм называется «прототипным наследованием».</p>
      <p>Свойство [[Prototype]] является внутренним и скрытым, но есть много способов задать его. Одним из них является использование __proto__. Свойство __proto__ — исторически обусловленный геттер/сеттер для [[Prototype]]</p>
      <p>Неважно, где находится метод: в объекте или его прототипе. При вызове метода this — всегда объект перед точкой.</p>
      <p>Цикл for..in проходит не только по собственным, но и по унаследованным свойствам объекта.</p>
      <p>Свойство F.prototype (не путать с [[Prototype]]) устанавливает[[Prototype]] для новых объектов при вызове new F().
      Значение F.prototype должно быть либо объектом, либо null. Другие значения не будут работать.
      Свойство "prototype" является особым, только когда оно назначено функции-конструктору, которая вызывается оператором new.</p>

      <p>Что выведет и почему?</p>
      <code>
        function Main () {}
        Main.prototype = { protected: true };
    
        const obj = new Main();
        Main.prototype = { protected: false };
    
        console.log('Object protection: ', obj.protected);
      </code>

      <p>Выведет true аотому что свойство prototype работает только для НОВЫХ объектов созданных через new от функции-конструктора</p>
    `,
  },

  {
    id: 136,
    title: 'Какая разница между композицией и наследованием?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://webdevblog.ru/prosto-o-kompozicii-agregacii-i-associacii-v-javascript/',
      },
      {
        label: 'Ссылка 2',
        href: 'https://gist.github.com/sandrig/d776ece2744c5a30883d4da07bca4877/',
      },
    ],
    answer: `
      <p>Наследование - это когда мы думаем о том, что такое объект. Композиция - когда мы думаем о том, что объект делает.</p>
      <p>Наследование делается обычно в классах. Мы наследуем от родителя нужные методы и генерируем новые дочерние классы</p>
      <p>Композиция обычно делается через функцию, но может встречаться и в классах (через метод конструктора). Композиция принимает нужные методы и добавляет в объект</p>
    `,
  },

  {
    id: 137,
    title: 'Почему не следует использовать конструкторы типа new String?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://javascript.plainenglish.io/javascript-boxing-wrappers-5b5ff9e5f6ab',
      },
    ],
    answer: `
      Тема от боксинг-анбоксинг. Потому что проверка на тип typeof будет выдавать объект
    `,
  },

  {
    id: 138,
    title:
      'Что такое записи (records) и кортежи (tuples)? Чем они отличаются от обычных объектов?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://habr.com/ru/post/504092/',
      },
    ],
    answer: `
      <p><strong>записи (records)</strong> — неизменяемая и сравниваемая по значению версия простых объектов;</p>
      <p><strong>кортежи (tuples)</strong> — неизменяемая и сравниваемая по значению версия массивов.</p>
      <code>
        #{x: 1, y: 4} === #{x: 1, y: 4} // true <br/>
        #['a', 'b'] === #['a', 'b'] // true
      </code>
      <p>записи и кортежи являются примитивами, при использовании typeof</p>
      <p>Ограничения</p>
      <p>Записи:</p>
      <p>ключи должны быть строками;
      значения должны быть примитивами (включая записи и кортежи).</p>
      <p>Кортежи:</p>
      <p>элементы должны быть примитивами (включая записи и кортежи).</p>
    `,
  },

  {
    id: 139,
    title:
      'Какие отличия в поведении ES5 функции-конструктора и класса ES2015?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 2,
    answer: `
      <p>По сути лишь записью и синтаксическим сахаром. Все равно все наследование происходит от прототипов. Однако в классе можно перезаписать конструктор</p>
    `,
  },

  {
    id: 140,
    title: 'Как реализовать паттерн «Модуль»?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://metanit.com/web/javascript/3.9.php',
      },
    ],
    answer: `
      <code>
        let foo = (function(){ </br>
          let obj = {greeting: "hello"};</br>
          </br>
          return {</br>
              display: function(){</br>
                  console.log(obj.greeting);</br>
              }</br>
          }</br>
        })();</br>
        foo.display();  // hello
      </code>
    `,
  },

  {
    id: 141,
    title: "Почему typeof null === 'object'?",
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://habr.com/ru/post/200664/',
      },
    ],
    answer: `
      <p>Причиной этого является то, что null, в отличие от undefined, был (и остается) часто использоваться там, где появляются объекты. Другими словами, null часто используется для обозначения пустой ссылки на объект. Когда Брендан Эйч создал JavaScript, он следовал той же парадигме, и имело смысл (возможно) вернуть "object". Фактически, спецификация ECMAScript определяет null как примитивное значение, которое представляет намеренное отсутствие какого-либо значения объекта (ECMA-262, 11.4.11).</p>
    `,
  },

  {
    id: 142,
    title: 'Что такое приведение (преобразование) типов в JS?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 2,
    links: [
      {
        label: 'Learn Javascript',
        href: 'https://learn.javascript.ru/type-conversions',
      },
    ],
    answer: `
      <p>Чаще всего операторы и функции автоматически приводят переданные им значения к нужному типу.</p>
      <p>Например, alert автоматически преобразует любое значение <strong>к строке</strong>. Математические операторы преобразуют <strong>значения к числам</strong>.</p>
      <p><strong>Логическое преобразование</strong> самое простое.
      Происходит в логических операциях, но также может быть выполнено явно с помощью функции Boolean(value).</p>
      <p>Правило преобразования:
      Значения, которые интуитивно «пустые», вроде 0, пустой строки, null, undefined и NaN, становятся false.
      Все остальные значения становятся true</p>
      `,
  },

  {
    id: 143,
    title:
      'Что такое явное и неявное приведение (преобразование) типов? + практическое',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 2,
    isPractise: true,
    links: [
      {
        label: 'Learn Javascript',
        href: 'https://learn.javascript.ru/type-conversions',
      },
      {
        label: 'Объяснения задачи',
        href: 'https://www.destroyallsoftware.com/talks/wat',
      },
    ],
    answer: `
      <p>Явное - когда мы сами преобразуем один тип в нужный нам другой тип</p>
      <p>Неявное - когда мы используем математические символы либо логические символы сравнения</p>
      <p>Что произойдет?</p>
      <code>
        {}+[]+{}+[1] // '0[object Object]1'<br/>
        !!"false" == !!"true" // true<br/>
        ['x'] == 'x' // true<br/>
      </code>
      <ol>
        <li>Объект при сложении всегда перевернётся в строку [object Object], а массив всегда в строку из содержимого через запятую. 
        <br/>
        []+[] // ничего, пустая строка
        <br/>
        {}+[]+{} // '[object Object][object Object]'
        <br/>
        {}+[] // 0
        <br/>
        []+{} // [object Object]
        <br/>
        {}+[]+{}+[1] // '0[object Object]1'
        </li>
        <li>Неважно что будет в строке - будет true</li>
        <li>При преобразовании массив развернет свое содержимое в строку через запятую</li>
      </ol>
      `,
  },

  {
    id: 144,
    title: 'Что такое Garbage Collector и как он работает?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 2,
    links: [
      {
        label: 'Learn Javascript',
        href: 'https://learn.javascript.ru/garbage-collection',
      },
    ],
    answer: `
      <p>Основной концепцией управления памятью в JavaScript является принцип достижимости. Если упростить, то «достижимые» значения – это те, которые доступны или используются. Они гарантированно находятся в памяти. Любое другое значение считается достижимым, если оно доступно из корня по ссылке или по цепочке ссылок.</p>
      <p>Существует базовое множество достижимых значений, которые не могут быть удалены (корни).</p>
      <ul>
        <li>Выполняемая в данный момент функция, её локальные переменные и параметры.</li>
        <li>Другие функции в текущей цепочке вложенных вызовов, их локальные переменные и параметры.</li>
        <li>Глобальные переменные.</li>
        <li>некоторые другие внутренние значения</li>
      </ul>
      <p>Сборка мусора выполняется автоматически. Мы не можем ускорить или предотвратить её.
      Объекты сохраняются в памяти, пока они достижимы.
      Если на объект есть ссылка – вовсе не факт, что он является достижимым (из корня): набор взаимосвязанных объектов может стать недоступен в целом, как мы видели в примере выше.</p>
      `,
  },

  {
    id: 145,
    title: 'Что такое Garbage Collector и как он работает?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 2,
    links: [
      {
        label: 'Learn Javascript',
        href: 'https://learn.javascript.ru/garbage-collection',
      },
    ],
    answer: `
      <p>Основной концепцией управления памятью в JavaScript является принцип достижимости. Если упростить, то «достижимые» значения – это те, которые доступны или используются. Они гарантированно находятся в памяти. Любое другое значение считается достижимым, если оно доступно из корня по ссылке или по цепочке ссылок.</p>
      <p>Существует базовое множество достижимых значений, которые не могут быть удалены (корни).</p>
      <ul>
        <li>Выполняемая в данный момент функция, её локальные переменные и параметры.</li>
        <li>Другие функции в текущей цепочке вложенных вызовов, их локальные переменные и параметры.</li>
        <li>Глобальные переменные.</li>
        <li>некоторые другие внутренние значения</li>
      </ul>
      <p>Сборка мусора выполняется автоматически. Мы не можем ускорить или предотвратить её.
      Объекты сохраняются в памяти, пока они достижимы.
      Если на объект есть ссылка – вовсе не факт, что он является достижимым (из корня): набор взаимосвязанных объектов может стать недоступен в целом, как мы видели в примере выше.</p>
      `,
  },

  {
    id: 146,
    title: 'Чем отличаются Observable и Promise?',
    category: [QuizletQuestionCategoryEnum.rxjs],
    level: 1,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://nicecoding.ru/v-chem-otlichie-observable-ot-promise.html',
      },
    ],
    answer: `
      <p>Promise обрабатывает одно событие, когда асинхронная операция завершается успешно или с ошибкой.</p>
      <p>Observable похож на Stream (поток) в других языках и позволяет пропускать ноль или более событий, в то время как обратный вызов вызывается для каждого события.
      Observable также имеет преимущество перед Promise в том, что запрос может быть отменен. Если результат HTTP-запроса на сервер или какая-либо другая дорогостоящая асинхронная операция больше не требуется, Observable позволяет отменить подписку, а Promise в конечном итоге вызовет успешный или неудачный обратный вызов даже если результат вам уже не требуется.</p>
    `,
  },

  {
    id: 147,
    title: 'Практическое на промисы',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 2,
    links: [
      {
        label: 'Learn Javascript',
        href: 'https://learn.javascript.ru/garbage-collection',
      },
    ],
    answer: `
      <code>
        Promise.resolve(10)
          .then(e => console.log(e)) // 1
          .then(e => Promise.resolve(e)) // 2
          .then(console.log) // 3
          .then(e => { // 4
            if (!e) {
              throw 'Error caught';
            }
          })
          .catch(e => { // 5
            console.log(e);
            return new Error('New error');
          })
          .then(e => { // 6
            console.log(e.message); 
          })
          .catch(e => { // 7
            console.log(e.message); 
          });
      </code>
      <ol>
        <li>Вначале вызовется (1), в консоль лог попадет 10, как результат выполнения промиса</li>
        <li>Вызовется (2), однако тут есть момент, что в передает он е как undefined. Возвращающий (1) then консоль лог сам по себе возвращает undefined, и он же попадает в следующий then</li>
        <li>В (2) не было консоль логов, но в (3) он вызовется и сразу отобразит undefined как принимающая и автовызывающаяся функция</li>
        <li>Вызовется (4) и так как в (3) консоль лог все также отдает undefined, то вызовется throw 'Error caught'</li>
        <li>Раз была ошибка в (4), то ближайший обработчик ошибок это (5). Отконсоль ложится вышвырнутая строка ошибки 'Error caught'</li>
        <li>ВНЕЗАПНО, то запуститься не (7), а (6), потому что ошибку мы создали как объект, но не вышвырнули ее. Поэтому она считается успешной, а не ошибочной и вызовет then</li>
      </ol>
      `,
  },

  {
    id: 148,
    title:
      'Статические методы промиса: Promise.all(), Promise.allSettled(), Promise.race()',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 2,
    links: [
      {
        label: 'Learn Javascript',
        href: 'https://learn.javascript.ru/promise-api#promise-resolve-reject',
      },
    ],
    answer: `
    <p>Мы ознакомились с пятью статическими методами класса <code>Promise</code>:</p>
    <ol>
      <li><code>Promise.all(promises)</code> – ожидает выполнения всех промисов и возвращает массив с результатами. Если любой из указанных промисов вернёт ошибку, то результатом работы <code>Promise.all</code> будет эта ошибка, результаты остальных промисов будут игнорироваться.</li>
      <li><code>Promise.allSettled(promises)</code> (добавлен недавно) – ждёт, пока все промисы завершатся и возвращает их результаты в виде массива с объектами, у каждого объекта два свойства:
      <ul>
      <li><code>state</code>: <code>"fulfilled"</code>, если выполнен успешно или <code>"rejected"</code>, если ошибка,</li>
      <li><code>value</code> – результат, если успешно или <code>reason</code> – ошибка, если нет.</li>
      </ul>
      </li>
      <li><code>Promise.race(promises)</code> – ожидает первый выполненный промис, который становится его результатом, остальные игнорируются.</li>
      <li><code>Promise.resolve(value)</code> – возвращает успешно выполнившийся промис с результатом <code>value</code>.</li>
      <li><code>Promise.reject(error)</code> – возвращает промис с ошибкой <code>error</code>.</li>
    </ol>
    <p>Из всех перечисленных методов, самый часто используемый – это, пожалуй, <code>Promise.all</code>.</p>
      `,
  },

  {
    id: 149,
    title:
      'Что такое дескрипторы свойств объектов? Расскажите об их практическом применении.',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 2,
    links: [
      {
        label: 'Learn Javascript 1 (+ getters, setters)',
        href: 'https://learn.javascript.ru/descriptors-getters-setters',
      },
      {
        label: 'Learn Javascript 2',
        href: 'https://learn.javascript.ru/property-descriptors',
      },
    ],
    answer: `
      <p>Помимо значения <strong><code>value</code></strong>, свойства объекта имеют три специальных атрибута (так называемые «флаги»).</p>
      <ul>
        <li><strong><code>writable</code></strong> – если <code>true</code>, свойство можно изменить, иначе оно только для чтения.</li>
        <li><strong><code>enumerable</code></strong> – если <code>true</code>, свойство перечисляется в циклах, в противном случае циклы его игнорируют.</li>
        <li><strong><code>configurable</code></strong> – если <code>true</code>, свойство можно удалить, а эти атрибуты можно изменять, иначе этого делать нельзя.</li>
      </ul>
      <p>Дескриптор позволяет задать свойство, которое на самом деле работает как функция. Для этого в нём нужно указать эту функцию в <code>get</code> или <code>set</code>.</p>
      <p>Метод Object.getOwnPropertyDescriptor позволяет получить полную информацию о свойстве.</p>
      <p>Чтобы изменить флаги, мы можем использовать метод Object.defineProperty(obj, propertyName, descriptor)</p>
      `,
  },

  {
    id: 150,
    title: 'Как защитить объект?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 2,
    links: [
      {
        label: 'Learn Javascript 1 (+ getters, setters)',
        href: 'https://learn.javascript.ru/descriptors-getters-setters',
      },
      {
        label: 'Learn Javascript 2',
        href: 'https://learn.javascript.ru/property-descriptors',
      },
    ],
    answer: `
    <p><strong>Дескрипторы свойств работают на уровне конкретных свойств.</p>
    
    <p><strong>Object.preventExtensions(obj)</strong>
    Запрещает добавлять новые свойства в объект.</p>

    <p><strong>Object.seal(obj)</strong>
    Запрещает добавлять/удалять свойства. Устанавливает configurable: false для всех существующих свойств.</p>
    
    <p><strong>Object.freeze(obj)</strong>
    Запрещает добавлять/удалять/изменять свойства. Устанавливает configurable: false, writable: false для всех существующих свойств.</p>
    
    
    <p>А также есть методы для их проверки:</p>
    
    <p><strong>Object.isExtensible(obj)</strong>
    Возвращает false, если добавление свойств запрещено, иначе true.</p>
    
    <p><strong>Object.isSealed(obj)</strong>
    Возвращает true, если добавление/удаление свойств запрещено и для всех существующих свойств установлено configurable: false.</p>
    
    <p><strong>Object.isFrozen(obj)</strong>
    Возвращает true, если добавление/удаление/изменение свойств запрещено, и для всех текущих свойств установлено configurable: false, writable: false.</p>
      `,
  },

  {
    id: 151,
    title: 'Зачем нужен конструктор Proxy?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 2,
    links: [
      {
        label: 'Learn Javascript',
        href: 'https://learn.javascript.ru/proxy',
      },
    ],
    answer: `
    <p>Объект Proxy «оборачивается» вокруг другого объекта и может перехватывать (и, при желании, самостоятельно обрабатывать) разные действия с ним, например чтение/запись свойств и другие.</p>
    <p><code>let proxy = new Proxy(target, handler);</code></p>
      `,
  },

  {
    id: 152,
    title: 'Какие отличия меж encodeURI() и encodeURIComponent()?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 2,
    answer: `
    <p>JavaScript метод encodeURI() объекта Global кодирует URI (англ. Uniform Resource Identifier – унифицированный идентификатор ресурса) заменяя каждый экземпляр определенных символов одной, двумя, тремя или четырьмя управ­ляю­щих по­сле­до­ва­тель­но­стей, представляющими кодировку символа UTF-8. Для того, чтобы декодировать URI, ранее созданный функцией encodeURI() вы можете воспользоваться методом decodeURI().</p>
    <p>Обращаю Ваше внимание на то, что метод encodeURI() не кодирует зарезервированные символы, имеющие особое значение в URI, а именно:</p>
    <p><code>A-Z a-z 0-9 ; , / ? : @ & = + $ - _ . ! ~ * ' ( ) #</code></p>
    <p>Остальные символы (кроме вышеуказанных) заменяются путем преобразования символа в его код UTF-8 и последующего кодирования каждого из полученных байтов шестнадцатеричной управляющей последовательностью в формате %xx. При этом ASCII-символы заменяются одной последовательностью %xx, с кодами от \u0080 до \u07ff двумя управляющими последовательностями, а все остальные 16-разрядные символы Юникода тремя управляющими последовательностями.</p>
    <p>Метод encodeURIComponent() отличается от метода encodeURI(). Метод encodeURIComponent() предполагает, что его параметр является не весь URI, а лишь фрагмент URI (такой как протокол, имя хоста, путь или строка запроса). По этой причине он преобразует все символы за исключением следующих:</p>
    <p><code>A-Z a-z 0-9 - _ . ! ~ * ' ( )</code></p>
      `,
  },

  {
    id: 153,
    title: 'Что такое генераторы?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 2,
    links: [
      {
        label: 'Learn Javascript',
        href: 'https://learn.javascript.ru/generators',
      },
    ],
    answer: `
    <p>Обычные функции возвращают только одно-единственное значение (или ничего).</p>
    <p>Генераторы могут порождать (yield) множество значений одно за другим, по мере необходимости. Генераторы отлично работают с перебираемыми объектами и позволяют легко создавать потоки данных.</p>
    <p>Для объявления генератора используется специальная синтаксическая конструкция: function*, которая называется «функция-генератор».</p>
    
    <code>
      function* generateSequence() { <br/>
        yield 1;<br/>
        yield 2;<br/>
        return 3;<br/>
      }<br/>
      let one = generator.next();
    </code>

    <p>Результатом метода next() всегда является объект с двумя свойствами:</p>
    <p>value: значение из yield.</p>
    <p>done: true, если выполнение функции завершено, иначе false.</p>
    `,
  },

  {
    id: 154,
    title: 'Что такое итераторы?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 2,
    links: [
      {
        label: 'Learn Javascript 1',
        href: 'https://learn.javascript.ru/iterable',
      },
      {
        label: 'Learn Javascript 2',
        href: 'https://learn.javascript.ru/iterator',
      },
    ],
    answer: `
    <ul>
      <li><em>Итератор</em> – объект, предназначенный для перебора другого объекта.</li>
      <li>У итератора должен быть метод <code>next()</code>, возвращающий объект <code>{done: Boolean, value: any}</code>, где <code>value</code> – очередное значение, а <code>done: true</code> в конце.</li>
      <li>Метод <code>Symbol.iterator</code> предназначен для получения итератора из объекта. Цикл <code>for..of</code> делает это автоматически, но можно и вызвать его напрямую.</li>
      <li>В современном стандарте есть много мест, где вместо массива используются более абстрактные «итерируемые» (со свойством <code>Symbol.iterator</code>) объекты, например оператор spread <code>...</code>.</li>
      <li>Встроенные объекты, такие как массивы и строки, являются итерируемыми, в соответствии с описанным выше.</li>
    </ul>
    `,
  },

  {
    id: 155,
    title: 'Что такое Symbol?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 2,
    links: [
      {
        label: 'Learn Javascript',
        href: 'https://learn.javascript.ru/symbol',
      },
    ],
    answer: `
    <p>По спецификации, в качестве ключей для свойств объекта могут использоваться только строки или символы. </p>
    <p>«Символ» представляет собой уникальный идентификатор. Создаются новые символы с помощью функции <code>let id = Symbol();</code></p>
    <p>При создании, символу можно дать описание (также называемое имя), в основном использующееся для отладки кода <code>let id = Symbol("id");</code></p>
    <p>Символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы. Описание – это просто метка, которая ни на что не влияет.</p>
    <p>Символы позволяют создавать «скрытые» свойства объектов, к которым нельзя нечаянно обратиться и перезаписать их из других частей программы.</p>
    <p>Символы имеют два основных варианта использования:</p>
    <ol>
      <li>
        <p>«Скрытые» свойства объектов.</p>
        <p>Если мы хотим добавить свойство в объект, который «принадлежит» другому скрипту или библиотеке, мы можем создать символ и использовать его в качестве ключа. Символьное свойство не появится в <code>for..in</code>, так что оно не будет нечаянно обработано вместе с другими. Также оно не будет модифицировано прямым обращением, так как другой скрипт не знает о нашем символе. Таким образом, свойство будет защищено от случайной перезаписи или использования.</p>
        <p>Так что, используя символьные свойства, мы можем спрятать что-то нужное нам, но что другие видеть не должны.</p>
      </li>
      <li>
        <p>Существует множество системных символов, используемых внутри JavaScript, доступных как <code>Symbol.*</code>. Мы можем использовать их, чтобы изменять встроенное поведение ряда объектов. Например, <code>Symbol.iterator</code> для итераторов, <code>Symbol.toPrimitive</code> для настройки преобразования объектов в примитивы и так далее.</p>
      </li>
    </ol>
    `,
  },

  {
    id: 156,
    title: 'Как перевести число в другую разрядную систему?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 2,
    answer: `
    <p>Преобразуйте число в шестнадцатеричную строку с помощью:</p>
    <code>
      hexString = yourNumber.toString(16);<br/>
      if (hexString.length % 2) {<br/>
        hexString = '0' + hexString;<br/>
      }
    </code>
    <p>и обратный процесс:</p>
    <code>yourNumber = parseInt(hexString, 16);</code>
    `,
  },

  {
    id: 157,
    title: 'Что такое карирование (currying)?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 2,
    links: [
      {
        label: 'Learn Javascript',
        href: 'https://learn.javascript.ru/currying-partials',
      },
    ],
    answer: `
    <p><strong>Каррирование</strong> – продвинутая техника для работы с функциями. Она используется не только в JavaScript, но и в других языках.</p>
    <p>Каррирование – это трансформация функций таким образом, чтобы они принимали аргументы не как f(a, b, c), а как f(a)(b)(c).</p>
    <p>Карирование нужно для частичного применения функций, или даже их мемоизации (кеширование внутри)</p>
    `,
  },

  {
    id: 158,
    title: 'Что такое мемоизация?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://habr.com/ru/company/ruvds/blog/332384/',
      },
      {
        label: 'Learn Javascript',
        href: 'https://learn.javascript.ru/currying-partials',
      },
    ],
    answer: `
    <p>Мемоизация - это функционал запоминания результата предыдущего выполнения</p>
    <p>Часто выполняется через карирование</p>
    <code>
      // простая чистая функция, которая возвращает сумму аргумента и 10 <br/>
      const add = (n) => (n + 10); <br/>
      console.log('Simple call', add(3)); <br/>
      // простая функция, принимающая другую функцию и <br/>
      // возвращающая её же, но с мемоизацией <br/>
      const memoize = (fn) => { <br/>
        let cache = {}; <br/>
        return (...args) => { <br/>
          let n = args[0];  // тут работаем с единственным аргументом <br/>
          if (n in cache) { <br/>
            console.log('Fetching from cache'); <br/>
            return cache[n]; <br/>
          } <br/>
          else { <br/>
            console.log('Calculating result'); <br/>
            let result = fn(n); <br/>
            cache[n] = result; <br/>
            return result; <br/>
          } <br/>
        } <br/>
      } <br/>
      <br/>
      // создание функции с мемоизацией из чистой функции 'add' <br/>
      const memoizedAdd = memoize(add); <br/>
      console.log(memoizedAdd(3));  // вычислено <br/>
      console.log(memoizedAdd(3));  // взято из кэша <br/>
      console.log(memoizedAdd(4));  // вычислено <br/>
      console.log(memoizedAdd(4));  // взято из кэша
    </code>
    `,
  },

  {
    id: 159,
    title: 'Что такое чейнинг функций?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 2,
    links: [
      {
        label: 'Learn Javascript',
        href: 'https://learn.javascript.ru/task/chain-calls',
      },
    ],
    answer: `
    <p><strong>Чейнинг</strong>, это такой тип замыкания, когда объект при выполнении своих методов возвращает собственный контекст this</p>
    <code>
      let ladder = { <br/>
        step: 0, <br/>
        up() { <br/>
          this.step++; <br/>
          return this; <br/>
        }, <br/>
        down() { <br/>
          this.step--; <br/>
          return this; <br/>
        }, <br/>
        showStep() { <br/>
          alert( this.step ); <br/>
          return this; <br/>
        } <br/>
      } <br/>
      <br/>
      ladder.up().up().down().up().down().showStep(); // 1
    </code>
    `,
  },

  {
    id: 160,
    title: 'Чем отличаются mouseout от mouseleave?',
    category: [QuizletQuestionCategoryEnum.frontend],
    level: 2,
    links: [
      {
        label: 'Learn Javascript',
        href: 'https://learn.javascript.ru/mousemove-mouseover-mouseout-mouseenter-mouseleave',
      },
    ],
    answer: `
    <p>Обработчик mouseout стоящий на контейнере будет ловить события mouseout от дочерних элементов, в то время как mouseleave - только от текущего элемента.</p>
    <p>Особенности, на которые стоит обратить внимание:</p>
    <ul>
      <li>При быстром движении мыши события не будут возникать на промежуточных элементах.</li>
      <li>События <code>mouseover/out</code> и <code>mouseenter/leave</code> имеют дополнительное свойство: <code>relatedTarget</code>. Оно дополняет свойство <code>target</code> и содержит ссылку на элемент, с/на который мы переходим.</li>
    </ul>
    <p>События <code>mouseover/out</code> возникают, даже когда происходит переход с родительского элемента на потомка. С точки зрения браузера, курсор мыши может быть только над одним элементом в любой момент времени – над самым глубоко вложенным.</p>
    <p>События <code>mouseenter/leave</code> в этом отличаются. Они генерируются, когда курсор переходит на элемент в целом или уходит с него. Также они не всплывают.</p>
    `,
  },

  {
    id: 161,
    title:
      'В каком порядке обрабатываются пользовательские события в DOM (click, mouseover и т.п.)?',
    category: [QuizletQuestionCategoryEnum.frontend],
    level: 2,
    links: [
      {
        label: 'Learn Javascript',
        href: 'https://learn.javascript.ru/events-and-timing-depth',
      },
    ],
    answer: `
    <h3>Очередь событий</h3>
    <p>Произошло одновременно несколько событий или во время работы одного случилось другое – как главному потоку обработать это?</p>
    <p>Если главный поток прямо сейчас занят, то он не может срочно выйти из середины одной функции и прыгнуть в другую. А потом третью. Отладка при этом могла бы превратиться в кошмар, потому что пришлось бы разбираться с совместным состоянием нескольких функций сразу.</p>
    <p>Поэтому используется альтернативный подход.</p>
    <p><strong>Когда происходит событие, оно попадает в очередь.</strong></p>
    <p>Внутри браузера непрерывно работает «главный внутренний цикл», который следит за состоянием очереди и обрабатывает события, запускает соответствующие обработчики и т.п.</p>
    <p><strong>Иногда события добавляются в очередь сразу пачкой.</strong></p>
    <p>Например, при клике на элементе генерируется несколько событий:</p>
    <ol>
      <li>Сначала <code>mousedown</code> – нажата кнопка мыши.</li>
      <li>Затем <code>mouseup</code> – кнопка мыши отпущена и, так как это было над одним элементом, то дополнительно генерируется <code>click</code> (два события сразу).</li>
    </ol>
    <p>Таким образом, при нажатии кнопки мыши в очередь попадёт событие <code>mousedown</code>, а при отпускании – сразу два события: <code>mouseup</code> и <code>click</code>. Браузер обработает их строго одно за другим: <code>mousedown</code> → <code>mouseup</code> → <code>click</code>.</p>
    <p>При этом каждое событие из очереди обрабатывается полностью отдельно от других.</p>
    `,
  },

  {
    id: 162,
    title: 'Что такое FIFO и LIFO? + практическое',
    category: [QuizletQuestionCategoryEnum.frontend],
    level: 2,
    isPractise: true,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://webdevblog.ru/stek-i-ochered-v-javascript/',
      },
    ],
    answer: `
    <h3>Стек</h3>
    <p>LIFO — last in first out (последний пришел — первым ушел)</p>
    <p>Структура данных стека выполняет две основные операции:</p>
    <ol>
      <li><strong>push</strong>—Эта операция отвечает за вставку или перемещение нового элемента в стек.</li>
      <li><strong>pop</strong>—Эта операция отвечает за удаление самого последнего элемента из стека.</li>
    </ol>
    
    <h3>Очередь</h3>
    <p>FIFO — first in first out (первым пришел — первым вышел»)</p>
    <p>Структура данных очереди имеет две основные операции:</p>
    <ol>
      <li><strong>enqueue (push)</strong>—Эта операция отвечает за вставку или отправку нового элемента в очередь.</li>
      <li><strong>dequeue (shift)</strong>—Эта операция отвечает за удаление первого элемента из очереди.</li>
    </ol>
    `,
  },

  {
    id: 163,
    title:
      'Сравните методы объекта event stopPropagation и stopImmediateProparation',
    category: [QuizletQuestionCategoryEnum.frontend],
    level: 2,
    answer: `
    <p>stopPropagation предотвратит выполнение любых родительских обработчиков stopImmediatePropagation, предотвратит выполнение каких-либо родительских обработчиков , а также любых других обработчиков</p>
    `,
  },

  {
    id: 164,
    title: 'Каковы есть подходы к оптимизации производительности вебстраницы?',
    category: [QuizletQuestionCategoryEnum.frontend],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://habr.com/ru/post/112720/',
      },
    ],
    answer: `
    <ol>
      <li>Отсрочьте загрузку контента, когда есть такая возможность</li>
      <li>Используйте отдельные JS и CSS файлы а не инлайн или внутри html (для кеширования браузером)</li>
      <li>Используйте системы кэширования</li>
      <li>Реально-используемые размеры изображений в HTML</li>
      <li>Не используйте изображения для показа текста</li>
      <li>Оптимизируйте размеры изображения благодаря использованию правильного формата файла</li>
      <li>Оптимизируйте метод написания кода</li>
      <li>Загружайте JavaScript в конце документа</li>
      <li>Используйте сеть доставки контента (Content Delivery Network, CDN)</li>
      <li>Оптимизируйте веб-кэширование</li>
    </ol>
    `,
  },

  {
    id: 165,
    title: 'Как реализован механизм same-origin policy в браузере?',
    category: [QuizletQuestionCategoryEnum.frontend],
    level: 2,
    links: [
      {
        label: 'MDN',
        href: 'https://developer.mozilla.org/ru/docs/Web/Security/Same-origin_policy',
      },
      {
        label: 'Learn Javascript 1',
        href: 'https://learn.javascript.ru/same-origin-policy',
      },
      {
        label: 'Learn Javascript 2',
        href: 'https://learn.javascript.ru/cross-window-communication',
      },
    ],
    answer: `
    <p>Политика одинакового источника (same-origin policy) определяет как документ или скрипт, загруженный из одного источника (origin), может взаимодействовать с ресурсом из другого источника. Это помогает изолировать потенциально вредоносные документы, снижая количество возможных векторов атак.</p>
    <p>Две страницы имеют одинаковый origin (источник) если протокол , порт (если указан), и хост одинаковы для обоих страниц. </p>
    <p>Если одно окно попытается обратиться к другому, то браузер проверит, из одного ли они источника. Если нет – доступ будет запрещён.</p>
    <p>Ограничение «Same Origin» («тот же источник») ограничивает доступ окон и фреймов друг к другу, а также влияет на AJAX-запросы к серверу.</p>
    <p>Причина, по которой оно существует – безопасность. Если есть два окна, в одном из которых vasya-pupkin.com, а в другом gmail.com, то мы бы не хотели, чтобы скрипт из первого мог читать нашу почту.</p>
    `,
  },

  {
    id: 166,
    title: 'Назовите способы хранения данных в браузере',
    category: [QuizletQuestionCategoryEnum.frontend],
    level: 2,
    links: [
      {
        label: 'Learn Javascript',
        href: 'https://learn.javascript.ru/data-storage',
      },
    ],
    answer: `
    <ul>
      <li>Куки - это небольшие строки данных, которые хранятся непосредственно в браузере. Они являются частью HTTP-протокола/Одно куки вмещает до 4kb данных, разрешается более 20 куки на сайт (зависит от браузера).</li>
      <li>LocalStorage - данные, которые в них записаны, сохраняются после обновления страницы И даже после перезапуска браузера.  Лимит 2 Мб+, зависит от браузера (на localstorage и sessionstorage).</li>
      <li>SessionStorage - данные, которые в них записаны, сохраняются после обновления страницы. Лимит 2 Мб+, зависит от браузера (на localstorage и sessionstorage).</li>
      <li>IndexedDB - это встроенная база данных, более мощная, чем localStorage.</li>
    </ul>
    `,
  },

  {
    id: 167,
    title: 'Что такое Web Workers и зачем они нужны?',
    category: [QuizletQuestionCategoryEnum.frontend],
    level: 2,
    toBeReviewed: true,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://habr.com/ru/company/ruvds/blog/348424/',
      },
      {
        label: 'Ссылка 2',
        href: 'https://habr.com/ru/company/ruvds/blog/348424/',
      },
    ],
    answer: `
    !!!!ДОБАВИТЬ ИНФЫ, ПРОСМОТРЕТЬ БОЛЬШЕ ВИДОСОВ!!!
    <p>Веб-воркеры — это потоки, принадлежащие браузеру, которые можно использовать для выполнения JS-кода без блокировки цикла событий.</p>
    <p>Веб-воркеры позволяют разработчику размещать задачи, для выполнения которых требуются длительные и сложные вычисления, интенсивно задействующие процессор, в фоновых потоках, без блокировки пользовательского интерфейса, что позволяет приложениям оперативно реагировать на воздействия пользователя. Более того, нам больше не нужны обходные пути, вроде рассмотренного выше трюка с setTimeout для того, чтобы найти приемлемый способ взаимодействия с циклом событий.</p>
    <p>Веб-воркеры не реализованы в Node.js — там есть концепция «кластеров» или «дочерних процессов», а это уже немного другое.</p>
    <ul>
      <li>Выделенные воркеры (Dedicated Workers) - new Worker("demo_workers.js"); Экземпляры выделенных веб-воркеров создаются главным процессом. Обмениваться данными с ними может только он.</li>
      <li>Разделяемые воркеры (Shared Workers) - new SharedWorker('worker.js'); Очень простое различие: у Worker можно получить доступ только из скрипта, который его создал, доступ к SharedWorker может получить доступ из любого скрипта, который исходит из того же домена.</li>
      <li>Сервис-воркеры (Service Workers) - (обычно используется если херовый инет лиюо вообще его нет)  это воркеры, управляемые событиями, зарегистрированные с использованием источника их происхождения и пути. Они могут контролировать веб-страницу, с которой связаны, перехватывая и модифицируя команды навигации и запросы ресурсов, и выполняя кэширование данных, которым можно очень точно управлять. Всё это даёт нам отличные средства управления поведением приложения в определённой ситуации (например, когда сеть недоступна).</li>
    </ul>
    `,
  },

  {
    id: 168,
    title: 'Что такое Transferable-объекты?',
    category: [QuizletQuestionCategoryEnum.frontend],
    level: 2,
    toBeReviewed: true,
    answer: `
    <p>Для обмена данными между основным процессом и воркером без копирования памяти в js были введены transferable objects. Если коротко, то при передаче объекта arrayBuffer вместо того, чтобы копировать данные из памяти основного потока в поток воркера, вы можете их просто делегировать</p>
    <p>
    Чтобы передать transferable объекты необходимо их указать третьим аргументом в виде массива, а вот чтобы вернуть transferable необходимо в результате функции вернуть объект специального класса TransferableResponse.</p>
    `,
  },

  {
    id: 169,
    title: 'Что такое ResizeObserver?',
    category: [QuizletQuestionCategoryEnum.frontend],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://web.dev/i18n/ru/resize-observer/',
      },
    ],
    answer: `
    <p>До появления <code>ResizeObserver</code> вам приходилось прикреплять прослушиватель к событию документа <code>resize</code>, чтобы получать уведомления обо всех изменениях размеров области просмотра. Затем нужно было понять, какие элементы были затронуты этим изменением, и вызвать конкретную подпрограмму в обработчике событий, чтобы отреагировать соответствующим образом. Если вам требовались новые размеры элемента после изменения размера, нужно было вызвать <code>getBoundingClientRect()</code> или <code>getComputedStyle()</code>, что могло вызвать сбой макета, если не позаботиться о пакетной обработке <em>всех</em> чтений и <em>всех</em> записей.</p>
    <p>И все это не предусматривало случаи, когда меняется размер элементов без изменения размера главного окна. Например, добавление новых дочерних элементов, установка стиля элемента <code>display</code> в значение <code>none</code> или аналогичные действия могут изменить размер элемента, его предков или элементов одного с ним уровня.</p>
    <p>Поэтому <code>ResizeObserver</code> — полезный примитив. Он реагирует на изменение размера любого из наблюдаемых элементов, независимо от того, что вызвало это изменение. Он также обеспечивает доступ к новому размеру наблюдаемых элементов.</p>
    <code>
      var ro = new ResizeObserver(entries => { <br/>
        for (let entry of entries) {<br/>
          const cr = entry.contentRect;<br/>
          console.log('Element:', entry.target);<br/>
        }<br/>
      });<br/>
      <br/>
      // Наблюдаем один или несколько элементов<br/>
      ro.observe(someElement);
    </code>
    <p>В спецификации указано, что ResizeObserver должен обрабатывать все события изменения размера после макетирования и до отрисовки. Благодаря этому обратный вызов ResizeObserver становится идеальным местом для внесения изменений в макет вашей страницы. Поскольку обработка ResizeObserver происходит между макетированием и отрисовкой, такой подход аннулирует только макет, но не отрисовку.</p>
    `,
  },

  {
    id: 170,
    title: 'Что такое Web Accessibility?',
    category: [QuizletQuestionCategoryEnum.frontend],
    level: 2,
    links: [
      {
        label: 'MDN',
        href: 'https://developer.mozilla.org/ru/docs/Learn/Accessibility',
      },
      {
        label: 'Ссылка 1',
        href: 'https://www.w3.org/WAI/fundamentals/accessibility-intro/ru',
      },
      {
        label: 'Ссылка 2',
        href: 'https://medium.com/web-standards/pragmatic-a11y-rules-b16dd2f77685',
      },
    ],
    answer: `
    <p>Если веб-сайты и онлайн-приложения разработаны и спроектированы надлежащим образом, они могут использоваться людьми с ограниченными возможностями здоровья. Однако в настоящее время многие Интернет-сайты и сетевые приложения характеризуются ограниченной доступностью, что делает их использование для некоторых людей затруднительным или даже невозможным.</p>
    <ol>
      <li>Настаивайте на семантических HTML-элементах, или DIY</li>
      <li>Обеспечьте альтернативу для картинок, цветов, звуков и движения</li>
      <li>Привыкните использовать инструменты для проверки доступности в повседневной работе</li>
    </ol>
    <p>Простыми словами, нужно использовать специальные теги для специальных элементов. Использовать aria-аттрибуты. Работа с фокусом при табе. Картинки должны иметь альтернативный текст.</p>
    `,
  },

  {
    id: 171,
    title:
      'Опишите алгоритм создания функционала, обеспечивающий чтение содержимого .txt-файла при перетаскивании его из файловой системы в окно браузера',
    category: [QuizletQuestionCategoryEnum.frontend],
    level: 2,
    isPractise: true,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://professorweb.ru/my/html/html5/level5/5_4.php',
      },
    ],
    answer: `
    <ol>
      <li>Получение файла посредством input (явного или скрытого) либо драг-энд-дропа</li>
      <li>Чтение файла через var reader = new FileReader(); reader.readAsText(file); (readAsBinary, readAsDataURL)</li>
    </ol>
    `,
  },

  {
    id: 172,
    title: 'Объясните разницу между единицами измерения px, em, rem.',
    category: [QuizletQuestionCategoryEnum.markup],
    level: 2,
    links: [
      {
        label: 'Learn Javascript',
        href: 'https://learn.javascript.ru/css-units',
      },
    ],
    answer: `
    <ul>
      <li><code>px</code> – абсолютные пиксели, к которым привязаны и потому не нужны <code>mm</code>, <code>cm</code>, <code>pt</code> и <code>pc</code>. Используется для максимально конкретного и точного задания размеров.</li>
      <li><code>em</code> – задаёт размер относительно шрифта родителя, можно относительно конкретных символов: <code>"x"</code>(<code>ex</code>) и <code>"0"</code>(<code>ch</code>), используется там, где нужно упростить масштабирование компоненты.</li>
      <li><code>rem</code> – задаёт размер относительно шрифта <code>&lt;html&gt;</code>, используется для удобства глобального масштабирования: элементы которые планируется масштабировать, задаются в <code>rem</code>, а JS меняет шрифт у <code>&lt;html&gt;</code>.</li>
      <li><code>%</code> – относительно такого же свойства родителя (как правило, но не всегда), используется для ширин, высот и так далее, без него никуда, но надо знать, относительно чего он считает проценты.</li>
      <li><code>vw</code>, <code>vh</code>, <code>vmin</code>, <code>vmax</code> – относительно размера экрана.</li>
    </ul>
    `,
  },

  {
    id: 173,
    title: 'Использование переменных в CSS',
    category: [QuizletQuestionCategoryEnum.markup],
    level: 2,
    links: [
      {
        label: 'MDN',
        href: 'https://developer.mozilla.org/ru/docs/Web/CSS/Using_CSS_custom_properties',
      },
    ],
    answer: `
    <p>CSS переменные (пользовательские CSS-свойства) это сущности, определяемые автором CSS, хранящие конкретные значения, которые можно повторно использовать в документе. Они устанавливаются с использованием custom property нотации (например. --main-color: black;) и доступны через функцию var() (например. color: var(--main-color);) .</p>
    `,
  },

  {
    id: 174,
    title: 'Практическое на селектор * и свойство box-sizing',
    category: [QuizletQuestionCategoryEnum.markup],
    level: 2,
    isPractise: true,
    links: [
      {
        label: 'MDN',
        href: 'https://developer.mozilla.org/ru/docs/Web/CSS/Using_CSS_custom_properties',
      },
    ],
    answer: `
    <p>Что будет если использовать:</p>
    <code>* { box-sizing: border-box; } </code>
    <p>Все элементы поменяют принцип составления высоты и ширины блока. Согласно спецификации CSS ширина блока складывается из ширины содержимого (width), значений margin, padding и border. Аналогично обстоит и с высотой блока. Свойство box-sizing позволяет изменить этот алгоритм, чтобы свойства width и height задавали размеры не содержимого, а размеры блока.</p>
    `,
  },

  {
    id: 175,
    title: 'Как адаптировать страницу для печати?',
    category: [QuizletQuestionCategoryEnum.markup],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://vc.ru/flood/23660-print-style-sheets',
      },
    ],
    answer: `
    <p>Самое главное:</p>
    <ol>
      <li>Использовать отдельный файл (опционально): link media="print" href="print.css"</li>
      <li>Использовать медиа стили специальные для печати <code>body { font-size: 18px;}@media print { /* print styles go here */ body { font-size: 28px; }}</code></li>
      <li>В стилях для печати совершенно безопасно и даже рекомендуется использование таких абсолютных единиц как cm, mm, in, pt или pc.</li>
      <li>Использовать правила page для бордеров <code>@media print { @page { margin: 1cm; }}</code></li>
      <li>Убрать лишние элементы</li>
      <li>Сбрасывать стили</li>
      <li>Можно управлять разрывами страниц через page-break-before/page-break-after/page-break-inside, а также windows/orphans</li>
    </ol>
    `,
  },

  {
    id: 176,
    title: 'Опишите особенности кастомизации стилей обычных частей форм.',
    category: [QuizletQuestionCategoryEnum.markup],
    level: 2,
    answer: `
    <p>Нужно учитывать shadow dom, еще что разные браузеры по разному могут отображать поля и кнопки. Рекомендуется сбрасывать стили</p>
    `,
  },

  {
    id: 177,
    title: 'Что такое прогрессивный рендеринг? Какие подходы используются?',
    category: [QuizletQuestionCategoryEnum.markup],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://habr.com/ru/company/skillfactory/blog/540294/',
      },
    ],
    answer: `
    <p>Есть три типа рендеринга: на стороне клиента (все SPA), на стороне сервера и прогрессивный рендеринг</p>
    <p>Прогрессивный рендеринг на стороне сервера (PSSR) основан на концепции потоковой передачи HTML. PSSR разбивает страницы на осмысленные компоненты с помощью разделения кода. Эти части страницы управляются разными скриптами, и теперь у нас есть возможность сделать гидратацию независимо. Давайте посмотрим, как работает PSSR:</p>
    <ol>
      <li>Браузер запрашивает у сервера HTML-код.</li>
      <li>Сервер делает API запросы и сначала рендерит критический контент, а затем отправляет его клиенту.</li>
      <li>Браузер анализирует HTML и отображает его на экране.</li>
      <li>Сервер рендерит некритический контент и передает его браузеру.</li>
      <li>Затем браузер анализирует и отображает некритичный контент.</li>
      <li>Между тем JS-бандлы загружаются и выполняются в фоновом режиме, а браузер передаёт интерактивность элементам DOM.</li>
    </ol>
    `,
  },

  {
    id: 178,
    title:
      'Назовите несколько способов реализации lazy-loading медиаресурсов на странице.',
    category: [QuizletQuestionCategoryEnum.markup],
    level: 2,
    links: [
      {
        label: 'MDN',
        href: 'https://developer.mozilla.org/ru/docs/Web/Performance/Lazy_loading',
      },
    ],
    answer: `
    <ol>
      <li><strong>Разделение кода (code splitting).</strong> JavaScript, CSS и HTML могут быть разделены на небольшие части, называемые чанками (chunks). При первоначальной загрузке приложения вы можете отправлять не цельное приложение, а только необходимые части, например, только каркас разметки. Данные для заполнения этого каркаса могут быть подгружены позже, например, с помощью AJAX. Есть два вида разделения кода: Разделение по точкам входа (entrypoint) и Динамическое (dynamic import())</li>
      <li><strong>Указание типа "module"</strong>. Любой тег скрипта с type="module" рассматривается как JavaScript module, а его загрузка откладывается по умолчанию.</li>
      <li>По умолчанию CSS считается ресурсом, блокирующим рендеринг (render blocking). Это означает, что браузер не будет отображать контент до тех пор, пока не будет построена объектная модель CSS (CSSOM). Поэтому CSS-файл должен быть небольшим, чтобы он был доставлен так быстро, насколько это возможно. Рекомендуется использовать медиавыражения, для того чтобы вместо одного монолитного CSS-файла грузить специализированные.
        <br/>
        <code>
          link href="style.css"    rel="stylesheet" media="all" <br/>
          link href="portrait.css" rel="stylesheet" media="orientation:portrait" <br/>
          link href="print.css"    rel="stylesheet" media="print" <br/>
        </code>
      </li>
      <li>По умолчанию, <strong>загрузка шрифтов</strong> откладывается на тот момент, пока дерево рендера (render tree) не сформировано полностью. Это приводит к тому, что текст страницы может появиться не сразу.
      Вы можете переопределить такое поведение и загрузить шрифты заранее, используя <code>link rel="preload"</code>, CSS font-display свойство или Font Loading API.</li>
      <li><strong>Атрибут Loading в img, iframe Атрибут</strong> loading элемента img или  loading атрибут для iframe могут быть использованы, чтобы указать браузеру на необходимость отложить загрузку изображений / iframe до тех пор, пока пользователь не доскроллит до них.</li>
      <li><strong> Intersection Observer API</strong> 
      Intersection Observers позволяют вам узнать, как наблюдаемый вами элемент входит или выходит из зоны видимости браузера (viewport).</li>
      </ol>
    `,
  },

  {
    id: 179,
    title: 'Популярные шаблонизаторы и их особенности',
    category: [QuizletQuestionCategoryEnum.markup],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://proglib.io/p/templating-languages-and-engines',
      },
    ],
    answer: `
    <p>Помогают писать html код без дублирования кода. Требует постобработки для запуска</p>
    <p>Примеры: Mustache, Handlebars.js, Pug (Jade), JSX</p>
    `,
  },

  {
    id: 180,
    title: 'Популярные CSS методологии',
    category: [QuizletQuestionCategoryEnum.markup],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://webformyself.com/css-metodologii-css-bem-smacss-ecss/',
      },
      {
        label: 'Ссылка 2',
        href: 'https://habr.com/ru/post/256109/',
      },
    ],
    answer: `
    <ul>
      <li>БЭМ - Блок__Элемент_Модификатор</li>
      <li>SMACCS - предполагает деление стилей на категории от большего к меньшему: Base rules, Layout rules, Modules rules, State rules, Theme rules</li>
      <li>ECSS - инкапсуляции всего кода, создания совершенно нового компонента каждый раз, когда нужен компонент</li>
    </ul>
    `,
  },

  {
    id: 181,
    title: 'Как работает CSS Grid?',
    category: [QuizletQuestionCategoryEnum.markup],
    level: 2,
    links: [
      {
        label: 'MDN',
        href: 'https://developer.mozilla.org/ru/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout',
      },
    ],
    answer: `
    <p>Грид представляет собой пересекающийся набор горизонтальных и вертикальных линий, образующих колонки и строки. Элементы могут быть помещены в грид в пределах линий этих колонок и строк. Грид имеет следующие особенности:</p>
    <ul>
      <li>Фиксированные и гибкие размеры полос</li>
      <li>Расположение элемента в любом нужном блоке</li>
      <li>Создание дополнительных полос для хранения контента</li>
      <li>Управление выравниванием</li>
      <li>Управление перекрывающимся контентом</li>
    </ul>
    <p>Мы создаём grid контейнер, объявляя на элементе <code>display: grid</code> или <code>display: inline-grid.</code> </p>
    <p>Мы определяем ряды и колонки в нашей сетке при помощи свойств grid-template-columns и grid-template-rows</p>
    <p>Промежутки (gutters), или дорожки (alleys), между грид-ячейками могут быть созданы с помощью свойств grid-column-gap и grid-row-gap, или с помощью сокращённого свойства grid-gap. </p>
    `,
  },

  {
    id: 182,
    title: 'Какие форматы изображений поддерживают анимацию?',
    category: [QuizletQuestionCategoryEnum.markup],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://habr.com/ru/company/io/blog/261083/',
      },
    ],
    answer: `
    <ol>
      <li><strong>GIF</strong> - Это очень старый формат. Его показывают все браузеры. У него есть прозрачный слой, т.е. под картинкой будет виден фон, на котором она лежит. Для анимации сохраняет серию полноценных картинок. Это минус. Файл с 24 кадрами будет в 24 раза больше исходного статичного. Частично можно исправить тем, что некоторые кадры могут содержать прозрачный слой плюс изменения предыдущего кадра. GIF показывает только 256 цветов. Это можно исправить при помощи анимации. Мы создаем две картинки с разным набором цветов. Демонстрируем их с задержкой 0. В итоге получаем 256 + 256 = 512 цветов.</li>
      <li><strong>WebP</strong> - Этот формат появился в 2010 году. Разработчик, компания Google, позиционирует его как замену GIF и других форматов. WEBP имеет все возможности GIF, но только в улучшенном варианте:
      <br/>1. Эффективней с прозрачными слоями.
      <br/>2. При анимации последующий кадр хранит только изменения предыдущего. А раз так, то размер анимированного файла уменьшается.
      <br/>3. Изображение сжимается эффективнее.</li>
      <li><strong>APNG</strong> - Этот формат (Animated PNG) является расширением распространенного формата PNG. Однако разработчики последнего не включили это расширение в спецификацию. Получилось, что немногие программы могут его правильно отображать. Большинство браузеров покажет первый кадр статичной картинкой, а про анимацию забудет.</li>
      <li><strong>BPG</strong> - BPG — самый новый. Он был предложен в конце 2014 года. Формат позиционируется как замена JPEG со значительными улучшениями. Сжатие изображения будет эффективнее, чем у предка. Появится поддержка анимации (JPEG не умеет этого делать). Но формат только начинает свое развитие, рекомендовать его для использования еще нельзя, а вот следить за ним можно.</li>
    </ol>
    `,
  },

  {
    id: 183,
    title:
      'Как отследить прогресс / окончание CSS @keyframes анимаций или плавных переходов, реализуемых с помощью transition, в JS?',
    category: [QuizletQuestionCategoryEnum.markup],
    level: 2,
    links: [
      {
        label: 'Learn Javascript',
        href: 'https://learn.javascript.ru/css-animations',
      },
    ],
    answer: `
      element.addEventListener('transitionend', handle)
    `,
  },

  {
    id: 184,
    title:
      'Какие свойства CSS могут быть обработаны непосредственно через GPU? Аппаратное ускорение',
    category: [QuizletQuestionCategoryEnum.markup],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://habr.com/ru/company/odnoklassniki/blog/313978/',
      },
      {
        label: 'Ссылка 2',
        href: 'https://webformyself.com/apparatnoe-uskorenie-v-css-animacii/',
      },
    ],
    answer: `
      <p>Современные браузеры умеют рисовать некоторые части страницы на GPU (графический процессор). Особенно это заметно на анимациях. Например, анимация, сделанная с помощью CSS-свойства transform выглядит гораздо приятнее и плавнее, чем анимация, сделанная через top/left. </p>
    `,
  },

  {
    id: 185,
    title: 'Как переиспользовать элементы SVG на странице?',
    category: [QuizletQuestionCategoryEnum.markup],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'http://css.yoksel.ru/svg-groups-use/#:~:text=%3E-,use,%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C%20%D0%B8%D1%85%20%D0%B2%20%D0%BD%D1%83%D0%B6%D0%BD%D1%8B%D1%85%20%D0%BC%D0%B5%D1%81%D1%82%D0%B0%D1%85.',
      },
      {
        label: 'Ссылка 2',
        href: 'https://habr.com/ru/post/260645/',
      },
    ],
    answer: `
      <p><strong>use</strong> - Тег, позволяющий переиспользовать SVG-элементы. Можно копировать любые элементы внутри одной HTML-страницы. Также можно подключить библиотеку элементов в начале страницы, а затем использовать их в нужных местах.</p>
      <code>
        svg<br/>
          use x="0" y="0" xlink:href="#some_svg_element_id" <br/>
        /svg
      </code>
      `,
  },

  {
    id: 186,
    title:
      'Как реализовать иконочный шрифт из определенного набора SVG-файлов?',
    category: [QuizletQuestionCategoryEnum.markup],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://itchief.ru/html-and-css/icomoon',
      },
    ],
    answer: `
    <p>Иконочный шрифт представляет собой обыкновенный шрифт, в котором вместо традиционных символов используются значки (иконки).</p>
    <p>Использование иконок в таком формате является очень привлекательным решением. <strong>Во-первых, такими иконками очень просто управлять</strong>, т.е. изменять их размер, цвет и другие параметры. Осуществляется это с помощью таких же свойств CSS, которые применяются для стилизации обычного текста (<code>font-size</code>, <code>color</code> и др.). <strong>Во-вторых, в формате шрифта иконки находятся в векторном формате</strong>. Это означает то, что они хорошо масштабируются и отлично выглядят на экранах устройств с высокой плотностью пикселей. Кроме этого <strong>шрифт - это сжатый формат</strong>, а значит, для его загрузки может потребоваться гораздо меньше времени, чем для загрузки аналогичных векторных изображений. Ещё одним неоспоримым плюсом шрифтовых иконок является то, что <strong>они поддерживаются всеми браузерами</strong>. Осуществляется это благодаря созданию на базе одного пакета иконок шрифтов в различных форматах: <code>eot</code>, <code>ttf</code>, <code>svg</code> и <code>woff</code>. Это необходимо выполнить для того, что браузер использовал тот формат шрифта, который он "понимает". Потому что на текущий момент нет ни одного формата шрифта, который бы поддерживался всеми браузерами.</p>
    <p>Кроме достоинств у шрифтовых  иконок есть конечно и недостатки. Первый связан с тем, что они немного теряют четкость отрисовки при очень маленьких размерах из-за сглаживания. Второй недостаток заключается в том, что с помощью них нельзя реализовать сложную цветную графику. Если у вас к иконкам имеются такие требования, то в качестве их формата лучше использовать svg.</p>

    <p>Кроме IcoMoon есть ещё и другие онлайн сервисы для создания значков в виде шрифта. К ним относится "fontello.com", "fontastic.me", "glyphter.com", "pictonic.co" и др.</p>
    `,
  },

  {
    id: 187,
    title:
      'Что такое ложное жирное или ложное курсивное (Faux) начертание шрифтов?',
    category: [QuizletQuestionCategoryEnum.markup],
    level: 2,
    answer: `
    <p>Браузеры могут вытворять ужасные вещи с текстом. Если текст стилизован как жирный или курсив, но в данном шрифте отсутствует жирное или курсивное начертание, то браузеры компенсируют их отсутствие, пытаясь создать подобное начертание самостоятельно. В результате мы наблюдаем неуклюжую попытку подражания настоящему шрифтовому дизайну.</p>
    `,
  },

  {
    id: 188,
    title: 'Что такое #shadow-root в инспекторе HTML-страницы?',
    category: [QuizletQuestionCategoryEnum.markup],
    level: 2,
    links: [
      {
        label: 'MDN',
        href: 'https://habr.com/ru/post/180377/',
      },
    ],
    answer: `
    <p>Дочернее дерево размещается внутри некоторого элемента на странице. Функциональные границы между главным деревом документа и теневым называются shadow boundaries (теневые границы). Элемент, который размещает в себе теневое дерево, называется shadow host, а корень теневого дерево, соответственно, называется shadow root.</p>
    `,
  },

  {
    id: 189,
    title: 'Зачем нужны Custom Elements?',
    category: [QuizletQuestionCategoryEnum.markup],
    level: 2,
    links: [
      {
        label: 'Learn Javascript',
        href: 'https://learn.javascript.ru/custom-elements',
      },
    ],
    answer: `
    <p>Мы можем создавать пользовательские HTML-элементы, описываемые нашим классом, со своими методами и свойствами, событиями и так далее.</p>
    <p>Как только пользовательский элемент определён, мы можем использовать его наравне со встроенными HTML-элементами.</p>
    <p>Это замечательно, ведь словарь HTML-тегов богат, но не бесконечен. Не существует <code>&lt;easy-tabs&gt;</code>, <code>&lt;sliding-carousel&gt;</code>, <code>&lt;beautiful-upload&gt;</code>… Просто подумайте о любом другом теге, который мог бы нам понадобиться.</p>
    <p>Мы можем определить их с помощью специального класса, а затем использовать, как если бы они всегда были частью HTML.</p>
    <p>Существует два вида пользовательских элементов:</p>
    <ol>
      <li><strong>Автономные пользовательские элементы</strong> – «полностью новые» элементы, расширяющие абстрактный класс <code>HTMLElement</code>.</li>
      <li><strong>Пользовательские встроенные элементы</strong> – элементы, расширяющие встроенные, например кнопку <code>HTMLButtonElement</code> и т.п.</li>
    </ol>
    `,
  },

  {
    id: 190,
    title:
      'Почему удаление лишних символов пробелов/символов переноса в HTML не отражается на конечной производительности загрузки страницы?',
    category: [QuizletQuestionCategoryEnum.markup],
    level: 2,
    answer: `
    <p>Пробелы не учитываются, переносы строк в коде HTML игнорируются, весь текст отображается одной строкой; вместе с тем, добавление тега <br> переносит текст</p>
    `,
  },

  {
    id: 191,
    title: 'Что такое контекст отображения canvas?',
    category: [QuizletQuestionCategoryEnum.markup],
    level: 2,
    links: [
      {
        label: 'MDN',
        href: 'https://developer.mozilla.org/ru/docs/Web/API/Canvas_API/Tutorial/Basic_usage',
      },
    ],
    answer: `
    <p>Элемент <code>&lt;canvas&gt;</code> в документе создаётся с фиксированным размером элемента для рисования, который может иметь один или несколько контекстов для рендеринга, создавая и манипулируя содержимым для показа. В данном руководстве мы сфокусируемся на 2D рендеринге. Другие контексты могут предоставлять разные типы рендеринга, к примеру WebGl использует 3D контекст основанный на OpenGL ES.</p>
    <p>Холст изначально пустой и прозрачный. Первым делом скрипт получает доступ к контексту и отрисовывает его. Элемент <code>&lt;canvas&gt;</code> имеет&nbsp;метод &nbsp;<code>getContext()</code>, используется для получения контекста визуализации и её функции рисования. <code>getContext()</code> принимает один параметр, тип контекста. Для 2D графики, которая охвачена этим руководством будем использовать метку&nbsp;"2d".</p>
    `,
  },

  {
    id: 192,
    title: 'Как работает Dependency Injection?',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://habr.com/ru/post/232851/',
      },
    ],
    answer: `
    <p>Dependency Injection представляет собою пример паттерна композиции (есть еще наследование)</p>
    <p>Это когда вместо наследования от каких-либо родительских классов мы составляем определенное число нужных зависимостей, которые могут и не быть непосредственной частью абстрактного класса</p>
    `,
  },

  {
    id: 193,
    title: 'Что такое zone.js и ngZone?',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://habr.com/ru/company/ruvds/blog/476956/',
      },
      {
        label: 'Ссылка 2',
        href: 'https://angular.io/guide/zone',
      },
      {
        label: 'Ссылка 3',
        href: 'https://medium.com/@overthesanity/zone-js-%D0%BE%D1%82-%D0%B0-%D0%B4%D0%BE-%D1%8F-fdb995917968',
      },
    ],
    answer: `
    <p>zone.js - библиотека, которая помогает создать контекст выполнения асинхронных функций, запихивая это в зоны с функцией начала и функцией конца. То есть, она отслеживает все асинхронные события и запускает перерисовку</p>
    <p>Все это переросло в идею у Ангуляра, что если что-то меняется в js, то сразу должно отразиться в html</p>
    <p>Конечно же, у Ангуляра есть модификация, специально для фреймворка - ngZone, которая создает зону с именем angular и отслеживает асинхронщину.</p>
    <p>Проблема в том, что таким образом, ангуляр не смотрит за изменением каких лиюо свойств, а глупо перерисовывает по любым из действий</p>
    <p>Отключить zone.js можно через changeDetection: ChangeDetectionStrategy.OnPush, а потом самому вручную запускать механихму this._cdr.markForCheck()</p>
    <p>Также можно полностью отключить ее через main.ts, прописав { ngZone: 'noop' }</p>
    `,
  },

  {
    id: 194,
    title: 'Как работает Change detection?',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://angular.io/api/core/ChangeDetectorRef',
      },
      {
        label: 'Ссылка 2',
        href: 'https://habr.com/ru/post/327004/',
      },
    ],
    answer: `
    <p>Благодаря библиотеке zone.js в ангуляре есть 2 стратегии изменений</p>
    <p>Простая: ChangeDetectionStrategy.Default, которая легкая и реагирует на любую функцию и в том числе асинхронную, перерисовывая компонент</p>
    <p>Альтернативная: ChangeDetectionStrategy.OnPush, которую нужно вызывать самостоятельно, когда мы знаем что точно в этом месте стоит перерисовать компонент</p>
    <p>Перерендер OnPush происходит зачастую через функцию this._cdr.markForCheck() (проверяет только текущий компонент), либо не очень рекомендуется this._cdr.detectChanges(), который запускает сразу и для потомков тоже</p>
    <p>Также есть методы reattach() и deatach(), которые позволяют выключать на определенное время возможне вызовы markForCheck или detectChanges</p>
    <p>Есть еще checkNoChanges() - который просто говорит что нет изменений</p>
    `,
  },

  {
    id: 195,
    title: 'Как выполнить конфигурацию HTTP-сервиса?',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 1,
    answer: `
    <p>Через интерсепторы. Интерсепторы - это перехватчики, которые могут реагировать как на реквест, так и на респонс, модифицируя запрос</p>
    `,
  },

  {
    id: 196,
    title: 'Как подготовить сборку к деплою?',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 1,
    answer: `
    <p>Проверить environments, тесты и запуститть ng build -prod</p>
    `,
  },

  {
    id: 197,
    title: 'Что такое NgRx? Когда следует использовать?',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 1,
    answer: `
    <p>NgRx - библиотека, которая позволяет создавать паттерны обзервер. Используется постоянно при использовании ангуляра, а также когда нам нужны обрерверы, потоки и подписки</p>
    `,
  },

  {
    id: 198,
    title:
      'В каких вариантах лучше использовать Renderer-сервис заместо нативных способов?',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://habr.com/ru/company/infowatch/blog/330030/',
      },
    ],
    answer: `
    <p>Renderer - позволяет создавать разные html элементы и модифицировать их, когда мы не хотим использовать обычный темплейт. Можно использовать хорошо в том случае, кода у нас крайне динамичный компонент (например, график), модалка, алерты</p>
    `,
  },

  {
    id: 199,
    title: 'Зачем нужен Resolver?',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://medium.com/nuances-of-programming/%D1%80%D0%B5%D0%B7%D0%BE%D0%BB%D0%B2%D0%B5%D1%80-%D0%B2-angular-%D0%B4%D0%BB%D1%8F-%D0%BF%D1%80%D0%B5%D0%B4%D0%B2%D1%8B%D0%B1%D0%BE%D1%80%D0%BA%D0%B8-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-932bf2c43ef1#:~:text=%D0%94%D0%BB%D1%8F%20%D1%87%D0%B5%D0%B3%D0%BE%20%D0%B2%20%D0%BC%D0%B0%D1%80%D1%88%D1%80%D1%83%D1%82%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8%20%D0%BD%D0%B0,%D0%B4%D0%BE%D0%BB%D0%B6%D0%BD%D1%8B%20%D0%B1%D1%8B%D1%82%D1%8C%20%D0%BE%D1%82%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D1%8B%20%D0%B2%20%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%B5.',
      },
    ],
    answer: `
    <p>Резолверы на Angular обычно используются, чтобы предоставить асинхронные данные загружаемому маршруту. И эти асинхронные данные должны быть отображены в компоненте. То есть, не лоадер грузить, а конкретно ждать вначале данные. Подключается в роутере, а данные будут получаться в this._routes.data.subscribe()</p>
    `,
  },

  {
    id: 200,
    title: 'Как работают и зачем нужны динамические компоненты?',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://angdev.ru/doc/dynamic-components/',
      },
    ],
    answer: `
    <p>Динамические компоненты создаются уже в скомпилированном приложении в момент его работы.</p>
    <p>В Angular динамическая компиляция компонентов реализована через сервис ComponentFactoryResolver.</p>
    <code>ng-template #dynamic /ng-template</code>
    <code>
    import { <br/>
      Component, <br/>
      ComponentFactoryResolver, <br/>
      ComponentRef, <br/>
      OnDestroy, <br/>
      ViewChild, <br/>
      ViewContainerRef, <br/>
    } from '@angular/core'; <br/>
    import { DynamicComponent } from './dynamic.component'; <br/>
    <br/>
    @Component({ <br/>
      selector: 'my-app', <br/>
      templateUrl: './app.component.html', <br/>
      styleUrls: ['./app.component.css'], <br/>
    }) <br/>
    export class AppComponent implements OnDestroy { <br/>
      @ViewChild('dynamic', { read: ViewContainerRef }) <br/>
      private viewRef: ViewContainerRef; <br/>
      <br/>
      private componentRef: ComponentRef<DynamicComponent>; <br/>
      <br/>
      constructor( <br/>
        private readonly componentFactoryResolver: ComponentFactoryResolver <br/>
      ) {} <br/>
      <br/>
      showDynamicComponent(): void { <br/>
        this.viewRef.clear(); // destroys all views in container <br/>
        const componentFactory =
          this.componentFactoryResolver.resolveComponentFactory(DynamicComponent); <br/>
        this.componentRef = this.viewRef.createComponent(componentFactory); <br/>
      } <br/>
    }
    </code>
    `,
  },

  {
    id: 201,
    title: 'Какая разница между @ViewChild и @ContentChild?',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://tyapk.ru/blog/post/viewchildren-viewchild-contentchildren-and-contentchild',
      },
    ],
    answer: `
    <p>
      @ViewChild - querySelector<br/>
      @ViewChildren - querySelectorAll<br/>
      @ContentChild - querySelector внутри ng-content<br/>
      @ContentChildren - querySelectorAll внутри ng-content<br/>
    </p>
    `,
  },

  {
    id: 202,
    title: 'Что такое @HostBinding и @HostListener?',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://metanit.com/web/angular2/3.3.php',
      },
    ],
    answer: `
    <p>Используется в директивах либо в компонентах. В директивах - это отношение к элементу, на который була привязаня директива, а в компоненте - корневой html элемент компоненты</p>
    <p>@HostBinding - это значение аттрибутов [], @HostListener - действия ()</p>
    <p>Пример: @HostBinding('class.valid') isValid; </p>
    `,
  },

  {
    id: 203,
    title: 'Как кэшировать данные, используя сервисы или RxJS?',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://tyapk.ru/blog/post/rxjs-simple-cache',
      },
    ],
    answer: `
    <p>RxJs</p>
    <code>
      /** cached data */ </br>
      private _cache: Observable<WhateverResponse>; </br>
      </br>
      ... </br>
      </br>
      getData(): Observable<WhateverResponse> { </br>
          if (!this._cache) { </br>
              this._cache = this._http.get('url').pipe( </br>
                  publishReplay(1), </br>
                  refCount() </br>
              ); </br>
          } </br>
          return this._cache; </br>
      }  
    </code>
    <p>
      publishReplay(1) - буфер в одно сообщение. Каждый новый подписчик получит последний результат. </br>
      refCount() - автоматически вызывет методы connect(), если появляются подписчки и unsubscribe(), когда подписчиков не остаётся.
    </p>
    <p>Через сервис - да просто сохранять запросы, и если входные данные одинаковы, то проверять их в кеш объекте и возвращать результат вместо запроса на сервер</p>
    `,
  },

  {
    id: 204,
    title: 'Что такое асинхронная валидация форм?',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://angdev.ru/doc/forms-validation/#angular_2',
      },
    ],
    answer: `
    <p>Использование механизма асинхронной валидации (Angular async validators) позволяет проверять введенное значение на удаленном сервере. Например, проверка уникальности имени пользователя при регистрации.</p>
    <code>
      export function checkGoodsLeftValidator( </br>
        control: AbstractControl </br>
      ) { </br>
        return this.checkGoodsLeft(control.value).pipe( </br>
          tap((response) => { </br>
            return response ? null : { goodsLeft: true } </br>
          }) </br>
        ) </br>
      }
    </code>

    <code>
      @Component({ </br>
        selector: 'check-goods-left-validator-example', </br>
        templateUrl: </br>
          './check-goods-left-validator-example.component.html', </br>
      }) </br>
      export class CheckGoodsLeftValidatorExampleComponent { </br>
        orderForm: FormGroup </br>
        </br>
        constructor( </br>
          private fb: FormBuilder, </br>
          private goodsService: GoodsService </br>
        ) { </br>
          this._createForm() </br>
        } </br>
        </br>
        private _createForm() { </br>
          this.orderForm = this.fb.group({ </br>
            client: ['', [Validators.required]], </br>
            goodsCount: [ </br>
              '', </br>
              [Validators.required], </br>
              [checkGoodsLeftValidator.bind(this.goodsService)], </br>
            ], </br>
          }) </br>
        } </br>
      }
    </code>
    `,
  },

  {
    id: 205,
    title: 'Зачем нужна forRoot-функция модуля?',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://habr.com/ru/company/tinkoff/blog/467525/',
      },
      {
        label: 'Ссылка 2',
        href: 'https://tyapk.ru/blog/post/angular-configurable-modules',
      },
    ],
    answer: `
    <p>Для того, чтобы сервисы точно были зафиксированы в глобальном инжекторе, модуль с провайдерами импортируется только в AppModule. Со стороны импортируемого модуля нужно лишь создать статический метод, возвращающий ModuleWithProviders, который исторически получил название forRoot.</p>
    <p>Это функция в модуле (по сути название может быть любым), главная цель которого принимать параметры. И когда будет импортирование модуля в других, то можно будет пропихнуть параметр, от которого будет зависеть правильный импорт</p>
    `,
  },

  {
    id: 206,
    title:
      'Какая разница между декларированием и экспортом компонента из модуля?',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 2,
    answer: `
    <p>Обычное декларирование позволяет использовать компонент внутри текущего модуля, а экспорт внутри других модулей при импорте</p>
    `,
  },

  {
    id: 207,
    title:
      'Почему плохо «провайдировать» сервис из shared-модуля в lazy-loaded модуль?',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 2,
    answer: `
    <p>Он уже там будет, и это лишний код в бандл.</p>
    `,
  },

  {
    id: 208,
    title: 'Что такое ::ng-deep',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 2,
    answer: `
    <p>Так как все стили у нас в компоненте модульные - они не расрпространяются на дочерние классы. Но если очень хочется, то можно использовать блок ::ng-deep</p>
    `,
  },

  {
    id: 209,
    title: 'Что такое ViewEncapsulation',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://habr.com/ru/post/588969/',
      },
    ],
    answer: `
    <p>Стили в Angular описываются непосредственно в компоненте, к которому они относятся.</p>
    <p>Стили компонента, по умолчанию инкапсулированы внутри него и не воздействуют на элементы других компонентов. Но Angular позволяет изменять данное поведение через свойство декоратора компонента encapsulation. Есть три варианта:</p>
    <ul>
      <li><p><code>ViewEncapsulation.Emulated</code> - по умолчанию, модулицйирует стили посредством добавления доп символов-айдишников к аттрибутам стилей</p></li>
      <li><p><code>ViewEncapsulation.None</code></p> - если мы не хотим модульность, отключаем ее</li>
      <li><p><code>ViewEncapsulation.ShadowDom</code></p> - Данный тип реализует честную инкапсуляцию через ShadowDOM</li>
    </ul>
    `,
  },

  {
    id: 210,
    title: 'Какие тесты есть в Angular?',
    category: [QuizletQuestionCategoryEnum.angular],
    level: 2,
    answer: `
    <p>Unit и e2e. Простые (без использования частей ангуляр) и сложные (с использованием частей ангуляр)</p>
    `,
  },

  {
    id: 211,
    title: 'Что такое JSX?',
    category: [QuizletQuestionCategoryEnum.react],
    level: 1,
    links: [
      {
        label: 'React Official 1',
        href: 'https://ru.reactjs.org/docs/introducing-jsx.html',
      },
      {
        label: 'React Official 2',
        href: 'https://ru.reactjs.org/docs/rendering-elements.html',
      },
    ],
    answer: `
    <p>Это JSX&nbsp;— расширение языка JavaScript. Мы&nbsp;рекомендуем использовать его, когда требуется объяснить React, как должен выглядеть UI. JSX напоминает язык шаблонов, наделённый силой JavaScript.</p>
    <p>JSX представляет собой объекты. Babel компилирует JSX в вызовы React.createElement().</p>
    <code>
      const element = React.createElement( <br/>
        'h1', <br/>
        {className: 'greeting'}, <br/>
        'Привет, мир!' <br/>
      );
    </code>
    <p>Эти объекты называются React-элементами. Можно сказать, что они описывают результат, который мы хотим увидеть на экране. React читает эти объекты и использует их, чтобы конструировать и поддерживать DOM.</p>
    `,
  },

  {
    id: 212,
    title: 'В чем разница между функциональными и классовыми компонентами?',
    category: [QuizletQuestionCategoryEnum.react],
    level: 1,
    answer: `
    <p>Способом мысли (ООП и ФП) и написания. Функциональные лаконичные. У классовых есть методы жизненного цикла. У функциональных хуки. Еще классовых нужно постоянно биндить методы внутри.</p>
    `,
  },

  {
    id: 213,
    title:
      'Зачем и когда нужно передавать props в super() при использовании классовых компонентов?',
    category: [QuizletQuestionCategoryEnum.react],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://habr.com/ru/post/648987/',
      },
    ],
    answer: `
    <p>Super вызывает конструктор родителя. JavaScript требует, чтобы, если вы хотите использовать this в конструкторе, и использовать свойства родителя, вы должны сначала вызвать super. Пусть родитель делает свое дело! Передача props в super необходима, чтобы базовый конструктор React.Component мог инициализировать this.props со значением не undefined</p>
    `,
  },

  {
    id: 214,
    title:
      'Почему необходимо использовать setState() для обновления внутреннего состояния компонента?',
    category: [QuizletQuestionCategoryEnum.react],
    level: 2,
    links: [
      {
        label: 'React Official',
        href: 'https://ru.reactjs.org/docs/faq-state.html',
      },
    ],
    answer: `
    <p>setState() планирует обновление объекта состояния компонента. Когда состояние изменяется, компонент отвечает переотрисовкой.</p>
    `,
  },

  {
    id: 215,
    title: 'В чем заключается принцип подъема состояния?',
    category: [QuizletQuestionCategoryEnum.react],
    level: 2,
    links: [
      {
        label: 'React Official',
        href: 'https://ru.reactjs.org/docs/lifting-state-up.html#:~:text=%D0%9A%D0%BE%D0%B3%D0%B4%D0%B0%20%D0%BC%D1%8B%20%D0%BE%D0%B1%D0%BD%D0%BE%D0%B2%D0%BB%D1%8F%D0%B5%D0%BC%20%D0%BF%D0%BE%D0%BB%D0%B5%20%D0%B2%D0%B2%D0%BE%D0%B4%D0%B0,%D0%AD%D1%82%D0%BE%20%D0%BD%D0%B0%D0%B7%D1%8B%D0%B2%D0%B0%D0%B5%D1%82%D1%81%D1%8F%20%C2%AB%D0%BF%D0%BE%D0%B4%D1%8A%D1%91%D0%BC%20%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F%C2%BB.',
      },
    ],
    answer: `
    <p>В React совместное использование состояния достигается перемещением его до ближайшего предка компонентов, которым оно требуется. Это называется «подъём состояния». Простими словами, если два дочерних используют одно и то же стостояние - то лучше запихнуть его в родитель.</p>
    `,
  },

  {
    id: 216,
    title: 'Какие библиотеки менеджмента состояния React-приложения вы знаете?',
    category: [QuizletQuestionCategoryEnum.react],
    level: 1,
    answer: `
    <ul>
      <li>Redux - самый популярный способ хранения глобального стейта. Крайне многословный</li>
      <li>Mobx - простой способ зранения глобального стейта</li>
      <li>React Query - для лоадеров и эрроров апи-запросов</li>
      <li>React Context - не библиотека, однако тоже не плохо для хранения редко изменяющегося состояния</li>
    </ul>
    `,
  },

  {
    id: 217,
    title: 'Расскажите о базовом принципе работы React Hooks',
    category: [QuizletQuestionCategoryEnum.react],
    level: 2,
    links: [
      {
        label: 'React Official',
        href: 'https://ru.reactjs.org/docs/hooks-intro.html',
      },
    ],
    answer: `
    <p>Хуки — нововведение в React 16.8, которое позволяет использовать состояние и другие возможности React без написания классов.</p>
    <p>Чтобы решить эту проблему, хуки позволяют разбить один компонент на маленькие функции по их назначению (например, подписке или загрузке данных), а не на основе методов жизненного цикла. Вы также можете контролировать внутреннее состояние с помощью редюсера, чтобы поведение было более предсказуемым.</p>
    `,
  },

  {
    id: 218,
    title: 'Что такое createRef и useRef?',
    category: [QuizletQuestionCategoryEnum.react],
    level: 2,
    links: [
      {
        label: 'React Official',
        href: 'https://ru.reactjs.org/docs/refs-and-the-dom.html',
      },
    ],
    answer: `
    <p>Рефы - это доступ к html элементам после их рендера напрямую.</p>
    <p>Доступ в классовых компонентах идет через createRef</p>
    <code>
      this.myRef = React.createRef(); <br/>
      ... <br/>
      return <div ref={this.myRef} />;
    </code>
    <p>Доступ в функциональных компонентах идет через хук useRef</p>
    <code>
      const refContainer = useRef(initialValue); <br/>
      ... <br/>
      return <div ref={this.refContainer} />;
    </code>
    `,
  },

  {
    id: 219,
    title: 'Когда следует использовать Ref?',
    category: [QuizletQuestionCategoryEnum.react],
    level: 2,
    links: [
      {
        label: 'React Official',
        href: 'https://ru.reactjs.org/docs/refs-and-the-dom.html',
      },
    ],
    answer: `
    <p>Когда нам нужны минимальные действия связанные с шаблоном, не влияющее на состояние. Отличный пример - изменение фокуса в инпутах, вызов анимаций, интеграция со сторонними dom-библиотеками</p>
    `,
  },

  {
    id: 220,
    title: 'Какие минусы есть у библиотеки React?',
    category: [QuizletQuestionCategoryEnum.react],
    level: 2,
    answer: `
      <ul>
        <li>Не фреймворк а библиотека, все части добавляются отдельно</li>
        <li>Низкий порог вхождения, много джунов</li>
        <li>Простота иногда развращает и делает хреновый код</li>
      </ul>
    `,
  },

  {
    id: 221,
    title: 'Какие паттерны используете вместе с React?',
    category: [QuizletQuestionCategoryEnum.react],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://habr.com/ru/post/309422/',
      },
    ],
    answer: `
    <ul>
      <li><b>Flux архитектура</b></li>
      <li><b>Простые компоненты</b> — Stateless function</li>
      <li><b>JSX распределение атрибутов</b> — JSX Spread Attributes</li>
      <li><b>Деструктуризация аргументов</b> — Destructuring Arguments</li>
      <li><b>Условный рендеринг</b> — Conditional Rendering</li>
      <li><b>Типы потомков</b> — Children Types</li>
      <li><b>Массив как потомок</b> — Array as children</li>
      <li><b>Функция как потомок</b> — Function as children</li>
      <li><b>Функция в render</b> — Render callback</li>
      <li><b>Проход по потомкам</b> — Children pass-through</li>
      <li><b>Перенаправление компонента</b> — Proxy component</li>
      <li><b>Стилизация компонентов</b> — Style component</li>
      <li><b>Переключатель событий</b> — Event switch</li>
      <li><b>Компонент-макет</b> — Layout component</li>
      <li><b>Компонент-контейнер</b> — Container component</li>
      <li><b>Компоненты высшего порядка</b> — Higher-order component</li>
    </ul>
    `,
  },

  {
    id: 222,
    title: 'Что такое HOC?',
    category: [QuizletQuestionCategoryEnum.react],
    level: 2,
    links: [
      {
        label: 'React Official',
        href: 'https://ru.reactjs.org/docs/higher-order-components.html',
      },
    ],
    answer: `
    <p>Компонент высшего порядка (Higher-Order Component, HOC) — это один из продвинутых способов для повторного использования логики. HOC не являются частью API React, но часто применяются из-за композиционной природы компонентов.</p>
    <p>Говоря просто, компонент высшего порядка — это функция, которая принимает компонент и возвращает новый компонент.</p>
    `,
  },

  {
    id: 223,
    title:
      'Оптимизация React-приложений. Инструменты оценки производительности',
    category: [QuizletQuestionCategoryEnum.react],
    level: 2,
    links: [
      {
        label: 'React Official',
        href: 'https://ru.reactjs.org/docs/optimizing-performance.html',
      },
    ],
    answer: `
    <p>React использует несколько умных подходов для минимизации количества дорогостоящих DOM-операций, необходимых для обновления пользовательского интерфейса. Для многих приложений, использование React приведёт к быстрому пользовательскому интерфейсу без особых усилий по оптимизации производительности. Тем не менее, существует несколько способов ускорить React-приложение.</p>
    <ul>
      <li>Использование продакшен-сборки и ее модификация</li>
      <li>Уменьшение количества ререндеринга</li>
      <li>Минимизация сложных функций</li>
      <li>Использование веб-врокеров</li>
    </ul>
    <p>Проверить производительность можно через Chrome Dev Tools, React Profiler, React Developer Tools</p>
    `,
  },

  {
    id: 224,
    title: 'Можно ли приложение React встроить в другое приложение React?',
    category: [QuizletQuestionCategoryEnum.react],
    level: 2,
    answer: `
    <p>Нет. Но можно запустить их из разных контейнеров. И то будет куча ререндера.</p>
    `,
  },

  {
    id: 225,
    title:
      'Каждый раз, когда вы делаете pull, почему-то случается конфликт в последней строке во всех редактируемых файлах. Что происходит?',
    category: [QuizletQuestionCategoryEnum.git],
    level: 2,
    answer: `
    <p>Изменения с удаленного (origin) репозитория конфликтуют с текущими и не могут вставиться через fast-forward. Конфликт требует решения на стороне локального репозитория</p>
    `,
  },

  {
    id: 226,
    title: 'Что делает команда git fetch? Чем она отличается от git pull?',
    category: [QuizletQuestionCategoryEnum.git],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://tproger.ru/explain/git-pull-and-git-fetch-whats-the-difference/l',
      },
    ],
    answer: `
    <p>Команда git fetch загружает коммиты, файлы и ссылки из удаленного (origin) репозитория в ваш локальный репозиторий. Однако он не сливает их в текущую ветку.</p>
    <p>При использовании pull, git пытается сделать всё за вас. Он сливает любые внесённые коммиты в ветку, в которой вы сейчас работаете. Команда pull автоматически сливает коммиты, не давая вам сначала просмотреть их. Если вы не пристально следите за ветками, выполнение этой команды может привести к частым конфликтам.</p>
    <p>Грубо говоря, по дефолту git pull — это шоткод для последовательности двух команд: git fetch (получение изменений с сервера) и git merge (сливание в локальную копию).</p>
    `,
  },

  {
    id: 227,
    title: 'Что такое CI/CD? Зачем это нужно?',
    category: [QuizletQuestionCategoryEnum.other],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://habr.com/ru/company/southbridge/blog/649027/',
      },
    ],
    answer: `
    <p><strong>CI/CD</strong> — это одна из DevOps практик, которая позволяет разработчикам чаще и надёжнее развёртывать изменения ПО, свести к минимуму ошибки, повысить темпы сборки и качество разрабатываемого продукта. Представляет собой комбинацию continuous integration и continuous delivery.</p>
    <p><strong>CI</strong>, или <strong>непрерывная интеграция</strong> — процесс постоянной разработки ПО с интеграцией в основную ветвь. Автоматически собирает софт, тестирует его и оповещает, если что-то идёт не так.</p>
    <p><strong>CD</strong>, или <strong>непрерывная доставка</strong> — процесс постоянной доставки ПО до потребителя. Обеспечивает разработку проекта небольшими частями и гарантирует, что он может быть отдан в релиз в любое время без дополнительных ручных проверок.</p>
    <p>Как выглядит цикл CI/CD:</p>
    <ol><li><p>Разработчик пишет код, проводит начальное тестирование, чтобы не было ошибок, и фиксирует изменения в своей рабочей ветке. Затем соединяет модифицированный код с рабочим кодом из основной ветки.</p></li><li><p>Система, выбранная инструментом CI, замечает, что в коде произошли изменения и запускает автоматическую сборку и автоматическое тестирование программы.</p></li><li><p>Если автоматическое тестирование прошло успешно, ПО отдаётся для ручного тестирования команде тестировщиков.</p></li><li><p>После исправления недочётов, обнаруженных во время ручного тестирования, запускается автоматизированная установка ПО на серверах компании.</p></li><li><p>Осуществляется поддержка новой версии программы и её мониторинг.</p></li><li><p>Собираются запросы на исправление недочётов и багов, разработчик вносит изменения в код, и процесс повторяется.</p></li></ol>
    <p>Основное преимущество CI/CD в том, что разработчику нужно только написать код, а остальные процессы по тестированию, сборке и доставке проходят автоматически.</p>
    `,
  },

  {
    id: 228,
    title: 'Зачем нужен package-lock.json?',
    category: [QuizletQuestionCategoryEnum.other],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://defront.ru/posts/2020/10-october/22-lockfile-guide/',
      },
    ],
    answer: `
    <p>При повторной установке пакетов с зафиксированными версиями результирующий node_modules может отличаться, так как могут быть обновлены зависимости зависимостей. Чтобы добиться детерминированной установки в npm используется файл package-lock.json, в котором явно описываются все версии всех зависимостей.</p>
    <p>При запуске команды <code>npm i</code> установщик получает список зависимостей проекта из package.json и во время их установки обновляет package-lock.json, записывая туда полное дерево зависимостей с необходимой метаинформацей. Для установки пакетов из package-lock.json нужно использовать другую команду — <code>npm ci</code>. Эта команда устанавливает все зависимости, создавая идентичное дерево зависимостей на момент последнего выполнения <code>npm i</code>. Кроме детерминированности <code>npm ci</code> даёт очень хороший буст в скорости установки пакетов, поэтому чаще всего её используют в CI-системах.</p>
    <p>Но всё же использование команды npm install не гарантирует установку тех же версий пакетов что были зафиксированы в package-lock.json. В зависимости от того что написано в package.json перед версией пакета (я о символах ~ и ^) пакеты всё же будут обновлены, а package-lock.json модифицирован самим npm в соответствии с установленными обновлениями. Это поведение крайне не желательно во время автоматических сборок проекта и при установке пакетов (тоже автоматической во время CI сценариев) для прогона тестов.</p>
    `,
  },

  {
    id: 229,
    title: 'В чем разница между npm install и npm ci?',
    category: [QuizletQuestionCategoryEnum.other],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://defront.ru/posts/2020/10-october/22-lockfile-guide/',
      },
    ],
    answer: `
    <p>При запуске команды <code>npm i</code> установщик получает список зависимостей проекта из package.json и во время их установки обновляет package-lock.json, записывая туда полное дерево зависимостей с необходимой метаинформацей. Для установки пакетов из package-lock.json нужно использовать другую команду — <code>npm ci</code>. Эта команда устанавливает все зависимости, создавая идентичное дерево зависимостей на момент последнего выполнения <code>npm i</code>. Кроме детерминированности <code>npm ci</code> даёт очень хороший буст в скорости установки пакетов, поэтому чаще всего её используют в CI-системах.</p>
    `,
  },

  {
    id: 230,
    title: 'Зачем нужны бандлеры?',
    category: [QuizletQuestionCategoryEnum.other],
    level: 2,
    answer: `
    <p>И здесь появляется бандлер (bundler). Это инструмент для сборки модулей в единые пакеты, имеющий доступ к файловой системе. Получающиеся пакеты совместимы с браузером, которому не нужен доступ к файловой системе. Бандлеры собирают скрипты в нужные файлики, подключают в нужном порядке, также могут добавлять функиональность, полиморфы (ie11) и минимизировать</p>
    <p>Примеры: webpack, browserify</p>
    `,
  },

  {
    id: 231,
    title: 'В чем разница между git merge и git rebase?',
    category: [QuizletQuestionCategoryEnum.git],
    level: 2,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://habr.com/ru/post/432420/',
      },
    ],
    answer: `
    <p>Git Merge и Git Rebase преследуют одну и ту же цель. Они предназначены для интеграции изменений из одной ветки в другую. Хотя конечная цель одинаковая, принципы работы разные.</p>
    
    <p><strong>Git Merge</strong> (cлияние) — обычная практика для разработчиков, использующих системы контроля версий. Независимо от того, созданы ли ветки для тестирования, исправления ошибок или по другим причинам, слияние фиксирует изменения в другом месте. Слияние принимает содержимое ветки источника и объединяет их с целевой веткой. В этом процессе изменяется только целевая ветка. История исходных веток остается неизменной.</p>
    <p><strong>Git Rebase</strong> (перемещение) — еще один способ перенести изменения из одной ветки в другую. Rebase сжимает все изменения в один «патч». Затем он интегрирует патч в целевую ветку. В отличие от слияния, перемещение перезаписывает историю, потому что она передает завершенную работу из одной ветки в другую. В процессе устраняется нежелательная история.</p>
    `,
  },

  {
    id: 232,
    title: 'Что такое staging area в git?',
    category: [QuizletQuestionCategoryEnum.git],
    level: 2,
    answer: `
    <p>Staging area переводится как "перевалочный пункт". То-есть это место, где хранится груз, готовый к дальнейшей отправке.</p>
    <p>Область подготовленных файлов (staging area) — это обычный файл, обычно хранящийся в каталоге Git, который содержит информацию о том, что должно войти в следующий коммит. Иногда его называют индексом (index), но в последнее время становится стандартом называть его областью подготовленных файлов. Область подготовленных файлов это уже не рабочий каталог, но ещё и не коммит.</p>
    `,
  },

  {
    id: 233,
    title: 'Опишите процесс code review',
    category: [QuizletQuestionCategoryEnum.git],
    level: 2,
    answer: `
    <p>Как следует из названия, code review — это процесс, при котором один или несколько разработчиков просматривают код, написанный другим разработчиком (автором), чтобы убедиться, что:</p>
    <ul>
      <li>в коде нет ошибок, нет ошибок или проблем</li>
      <li>он соответствует всем требованиям и стандартам качества и стиля</li>
      <li>код делает то, для чего предназначен</li>
      <li>при слиянии он не повредит кодовую базу</li>
    </ul>
    `,
  },

  {
    id: 234,
    title: 'Что представляет собой функциональное программирование?',
    category: [QuizletQuestionCategoryEnum.common],
    level: 3,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://habr.com/ru/post/570642/',
      },
      {
        label: 'Ссылка 2',
        href: 'https://habr.com/ru/post/479238/',
      },
    ],
    answer: `
    <p>Итак, что такое функциональное программирование? Этот термин возникает довольно часто, и каждый автор, пишущий о нем, дает собственное объяснение. На взгляд автора оригинала, самым простым и в то же время точным определением является следующее: функциональное программирование - это программирование с математическими функциями.</p>
    <p>Для того чтобы метод стал математической функцией, он должен соответствовать двум требованиям. Прежде всего, он должен быть ссылочно прозрачным (referentially transparent). Ссылочно прозрачная функция всегда дает один и тот же результат, если вы предоставляете ей одни и те же аргументы. Это означает, что такая функция должна работать только со значениями, которые мы передаем, она не должна ссылаться на глобальное состояние. Чистые функции</p>
    <ul>
      <li>Функциональная программа — программа, состоящая из чистых функций.</li>
      <li>Ссылочная прозрачность — свойство, при котором замена выражения на вычисленный результат этого выражения не изменяет желаемых свойств программы</li>
      <li>Отсутствие эффектов</li>
    </ul>
    `,
  },

  {
    id: 235,
    title:
      'Что такое TDD (Test Driven Development) / BDD (Behavior Driven Development)?',
    category: [QuizletQuestionCategoryEnum.common],
    level: 3,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://habr.com/ru/post/570642/',
      },
      {
        label: 'Ссылка 2',
        href: 'https://habr.com/ru/post/479238/',
      },
    ],
    answer: `
    <p>TDD (Test Driven Development) — Разработка на основе тестов.</p>
    <p>BDD (Behavior Driven Development) — Разработка на основе поведения.</p>

    <p>Как подойти к задаче, используя TDD подход:</p>
    <ol>
      <li>Пишем тест, в котором проверяем, что функция getCatFood() возвращает нужные значения в разных ситуациях</li>
      <li>Проверяем, что тесты упали (кода еще нет)</li>
      <li>Пишем код функции очень просто — так чтобы тесты прошли</li>
      <li>Проверяем, что тесты прошли</li>
      <li>На этом шаге можем задуматься о качестве кода. Можем спокойно рефакторить и изменять код как угодно, т.к. у нас есть тесты, которые с уверенностью скажут, что мы где-то ошиблись</li>
      <li>Повторяем все вышеуказанные шаги еще раз</li>
    </ol>

    <p>Как подойти к задаче, используя BDD подход:</p>
    <ol>
      <li>Процесс начинается с того что пользователь открывает форму</li>
      <li>Нам нужно протестировать числа которые выдает форма</li>
      <li>Нам нужно ввести 10–20 разных значений</li>
      <li>Проверка в данном случае это нажатие на Submit кнопку и проверка значения</li>
      <li>Тест пройдет если результат на форме соответствует “правильным” значениям</li>
    </ol>
    `,
  },

  {
    id: 236,
    title: 'Расскажите подробно о работе HTTPS',
    category: [QuizletQuestionCategoryEnum.common],
    level: 3,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://firstssl.ru/faq/general-questions/chto-takoe-https',
      },
    ],
    answer: `
    <p><strong>HTTPS </strong>— протокол безопасной передачи данных, поддерживает технологию шифрования TLS/SSL.</p>
    <p>Стандартный протокол HTTP передаёт данные в открытом виде. Злоумышленники могут “вклиниться” в передачу — изменить или перехватить данные. В HTTPS &nbsp;для передачи данных создаётся защищённый канал. Вот как это происходит:</p>
    <p>Вася хочет перейти на сайт FirstSSL, защищённый SSL-сертификатом</p>
    <p>→ Васин браузер посылает запрос к сайту</p>
    <p>→ сайт отправляет в ответ копию сертификата</p>
    <p>→ если сертификат не поддельный, сайт и браузер тайно договариваются о секретном симметричном ключе</p>
    <p>С помощью этого ключа Васин браузер и сайт устанавливают защищённое HTTPS-соединение. Ключ шифрует данные – мошенники не могут получить доступ к паролям и номерам кредитных карт пользователей.</p>
    <p>Для каждого соединения с сайтом создается новый секретный ключ. Его нельзя перехватить – сайт и браузер договариваются о ключе тайно. И невозможно подобрать – обычно это набор из 100 и более букв и цифр.</p>
    `,
  },

  {
    id: 237,
    title: 'Что такое V8 Engine?',
    category: [QuizletQuestionCategoryEnum.common],
    level: 3,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://habr.com/ru/company/ruvds/blog/337460/',
      },
      {
        label: 'Ссылка 2',
        href: 'https://medium.com/nuances-of-programming/%D0%B4%D0%B2%D0%B8%D0%B6%D0%BE%D0%BA-javascript-%D1%87%D1%82%D0%BE-%D0%B2%D0%BD%D1%83%D1%82%D1%80%D0%B8-f0db9b988b90',
      },
    ],
    answer: `
    <p>Движки JavaScript — это не что иное, как программы, преобразующие код на JavaScript в код более низкого уровня, который компьютер сможет понять. Эти движки встроены в браузеры и веб-серверы (Node.js), что даёт возможность выполнять код и осуществлять компиляцию во время выполнения.</p>
    <p>Разве JavaScript — это не интерпретируемый язык? Краткий ответ: это зависит от реализации. Обычно JavaScript относят к интерпретируемым языкам, хотя вообще-то он компилируется. Современные компиляторы JavaScript фактически выполняют JIT-компиляцию, т.е. компиляцию «на лету», которая осуществляется во время работы программы.</p>
    <p>V8 — движок с открытым исходным кодом, написан на C++, его разработкой занимается Google.</p>
    <p>Движок с открытым кодом V8 был создан компанией Google, он написан на C++. Движок используется в браузере Google Chrome. Кроме того, что отличает V8 от других движков, он применяется в популярной серверной среде Node.js.</p>
    <p>При проектировании V8 разработчики задались целью улучшить производительность JavaScript в браузерах. Для того, чтобы добиться высокой скорости выполнения программ, V8 транслирует JS-код в более эффективный машинный код, не используя интерпретатор. Движок компилирует JavaScript-код в машинные инструкции в ходе исполнения программы, реализуя механизм динамической компиляции, как и многие современные JavaScript-движки, например, SpiderMonkey и Rhino (Mozilla). Основное различие заключается в том, что V8 не использует при исполнении JS-программ байт-код или любой промежуточный код.</p>
    `,
  },

  {
    id: 238,
    title:
      'В чем отличие компилируемыми и интерпритируемыми языками программирования?',
    category: [QuizletQuestionCategoryEnum.common],
    level: 3,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://tproger.ru/translations/programming-concepts-compilation-vs-interpretation/',
      },
    ],
    answer: `
    <h3>Компилируемые языки</h3>
    <p>Главное преимущество компилируемых языков — это скорость исполнения. Поскольку они конвертируются в машинный код, они работают гораздо быстрее и эффективнее, нежели интерпретируемые, особенно если учесть сложность утверждений некоторых современных скриптовых интерпретируемых языков.</p>
    <p>Низкоуровневые языки как правило являются компилируемыми, поскольку эффективность обычно ставится выше кроссплатформенности. Кроме того, компилируемые языки дают разработчику гораздо больше возможностей в плане контроля аппаратного обеспечения, например, управления памятью и использованием процессора. Примерами компилируемых языков являются C, C++, Erlang, Haskell и более современные языки, такие как Rust и Go.</p>
    <p>Проблемы компилируемых языков, в общем-то, очевидны. Для запуска программы, написаной на компилируемом языке, её сперва нужно скомпилировать. Это не только лишний шаг, но и значительное усложнение отладки, ведь для тестирования любого изменения программу нужно компилировать заново. Кроме того, компилируемые языки являются платформо-зависимыми, поскольку машинный код зависит от машины, на которой компилируется и исполняется программа.</p>
    <h3>Интерпретируемые языки</h3>
    <p>В отличие от компилируемых языков, интерпретируемым для исполнения программы не нужен машинный код; вместо этого программу построчно исполнят интерпретаторы. Раньше&nbsp;процесс интерпретации занимал очень много времени, но с приходом таких технологий, как <a href="https://tproger.ru/translations/basic-jit/" target="_blank" rel="noopener" data-wpel-link="internal">JIT-компиляция</a>, разрыв между компилируемыми и&nbsp;интерпретируемыми языками сокращается. Примерами интерпретируемых языков являются PHP, Perl, Ruby&nbsp;и&nbsp;Python. Вот некоторые из концептов, которые стали проще благодаря интерпретируемым языкам:</p>
    <ul>
      <li>Независимость от платформы;</li>
      <li>Рефлексия;</li>
      <li>Динамическая типизация;</li>
      <li>Меньший размер исполняемых файлов:</li>
      <li>Динамические области видимости.</li>
    </ul>
    <p>Основным недостатком интерпретируемых языком является их невысокая скорость исполнения. Тем не менее, JIT-компиляция позволяет ускорить процесс благодаря переводу часто используемых последовательностей инструкции в машинный код.</p>
    
    <p>Разве JavaScript — это не интерпретируемый язык? Краткий ответ: это зависит от реализации. Обычно JavaScript относят к интерпретируемым языкам, хотя вообще-то он компилируется. Современные компиляторы JavaScript фактически выполняют JIT-компиляцию, т.е. компиляцию «на лету», которая осуществляется во время работы программы.</p>
    `,
  },

  {
    id: 239,
    title: 'Реализация паттерна Class Free OOP',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 3,
    isPractise: true,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://observablehq.com/@bratter/class-free-oop',
      },
    ],
    answer: `
    <code>
      // Constructor functions are not called with new <br/>
      // They take some form of specification or config object as an argument <br/>
      // although could take any set of arguments as they are just normal functions <br/>
      function constructor(spec) { <br/>
      <br/>
        // Declare variables scoped to this function <br/>
        // All these are inside the function's scope and are inaccessibe from outside <br/>
        let <br/>
          // Destructure and process items coming from the spec <br/>
          // potentially assinging defaults and/or error checking as required <br/>
          {member} = spec, <br/>
          // Call other constructors and extra data/behaviors <br/>
          {other} = otherConstructor(spec), <br/>
          // Build methods that close over everything available in its containing block <br/>
          method = function () { <br/>
            // member, other, method, spec, etc. are available here, e.g. <br/>
            return member + other; <br/>
          }; <br/>
          <br/>
        // Anything that forms part of the public interface is put in the outgoing object <br/>
        // This object is then frozen, creating a hard, uncoruptible interface <br/>
        return Object.freeze({ <br/>
          method, <br/>
          other, <br/>
        }); <br/>
      }
    </code>
    `,
  },

  {
    id: 240,
    title: 'Реализация паттерна async disposer',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 3,
    isPractise: true,
    toBeReviewed: true,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://advancedweb.hu/what-is-the-async-disposer-pattern-in-javascript/',
      },
    ],
    answer: ``,
  },

  {
    id: 241,
    title: 'Использование регулярных выражений. Когда приемлемо/неприемлемо?',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 3,
    toBeReviewed: true,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://habr.com/ru/company/badoo/blog/343310/',
      },
    ],
    answer: `
    <p>Регулярные выражения — язык поиска подстроки или подстрок в тексте. Для поиска используется паттерн (шаблон, маска), состоящий из символов и метасимволов (символы, которые обозначают не сами себя, а набор символов).</p>
    <p>Это довольно мощный инструмент, который может пригодиться во многих случая — поиск, проверка на корректность строки и т.д. Спектр его возможностей трудно уместить в одну статью.</p>
    <p>Для работы с ними нужен текст, в котором мы будем искать или заменять подстроки, а также само регулярное выражение, описывающее правило поиска.</p>
    
    <p>Функции на match возвращают число найденных подстрок или false в случае ошибок. Функция на replace возвращает измененную строку/массив или null в случае ошибки. Результат можно привести к bool (false, если не было найдено значений и true, если было) и использовать вместе с if или assertTrue для обработки результата работы.</p>
    <p>В JS чаще всего мне приходится использовать:</p>
    <ul>
      <li>match</li>
      <li>test</li>
      <li>replace</li>
    </ul>
    `,
  },

  {
    id: 242,
    title: 'Как обмениваться данными между вкладками?',
    category: [QuizletQuestionCategoryEnum.frontend],
    level: 3,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://medium.com/nuances-of-programming/4-%D1%81%D0%BF%D0%BE%D1%81%D0%BE%D0%B1%D0%B0-%D0%BE%D0%B1%D0%BC%D0%B5%D0%BD%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D0%BC%D0%B8-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-%D0%B2%D0%BA%D0%BB%D0%B0%D0%B4%D0%BA%D0%B0%D0%BC%D0%B8-%D0%B1%D1%80%D0%B0%D1%83%D0%B7%D0%B5%D1%80%D0%B0-%D0%B2-%D1%80%D0%B5%D0%B6%D0%B8%D0%BC%D0%B5-%D1%80%D0%B5%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%B8-4d6e81b0f934',
      },
    ],
    answer: `
    <ol>
      <li>
      <p>«Events» («События») в локальном хранилище данных</p>
      <code>window.localStorage.setItem("loggedIn", "true");</code>
      <code>window.addEventListener('storage', (event) => { <br/>
        if (event.storageArea != localStorage) return; <br/>
        if (event.key === 'loggedIn') { <br/>
          // Делаем что-нибудь с «event.newValue» <br/>
        } <br/>
       });</code>
       <p>Но есть минусы:</p>
       <ul>
        <li>Событие не срабатывает для вкладки, на которой выполняется действие по вводу значений в хранилище.</li>
        <li>Этот подход имеет негативные последствия для большого объёма данных: из-за синхронности выполняемых в LocalStorage действий основной поток пользовательского интерфейса может быть заблокирован.</li>
       </ul>
      </li>

      <li>
        <p>API широковещательного канала</p>
        <code>
          const channel = new BroadcastChannel('app-data'); <br/>
          channel.postMessage(data);<br/>
          ...
          channel.addEventListener ('message', (event) => {<br/>
            console.log(event.data);<br/>
          });
        </code>
      </li>

      <li>
        <p>Сервис-воркеры для отправки сообщений</p>
        <code>
          navigator.serviceWorker.controller.postMessage({<br/>
            broadcast: data<br/>
          });<br/>
          ...<br/>
          addEventListener('message', async (event) => {<br/>
            if ('boadcast' in event.data ) {<br/>
              const allClients = await clients.matchAll();<br/>
              for (const client of allClients) {<br/>
              client.postMessage(event.broadcast);<br/>
              }<br/>
            }<br/>
          });
        </code>
      </li>

      <li>
        <p>Отправка сообщений между окнами</p>
        <code>
          targetWindow.postMessage(message, targetOrigin)<br/>
          ...<br/>
          рwindow.addEventListener("message", (event) => {<br/>
            if (event.origin !== "http://localhost:8080")<br/>
              return;<br/>
            // Делаем что-нибудь<br/>
          }, false);
        </code>
      </li>
    </ol>
    `,
  },

  {
    id: 243,
    title: 'Как браузер определяет, можно ли общаться между вкладками?',
    category: [QuizletQuestionCategoryEnum.frontend],
    level: 3,
    answer: `
    <p>Same-origin policy</p>
    `,
  },

  {
    id: 244,
    title: 'Что такое Content Security Policy?',
    category: [QuizletQuestionCategoryEnum.frontend],
    level: 3,
    links: [
      {
        label: 'MDN',
        href: 'https://developer.mozilla.org/ru/docs/Web/HTTP/CSP',
      },
      {
        label: 'Ссылка 2',
        href: 'https://habr.com/ru/company/nix/blog/271575/',
      },
      {
        label: 'Ссылка 3',
        href: 'https://habr.com/ru/company/nix/blog/271575/',
      },
    ],
    toBeReviewed: true,
    answer: `
    <p>Content Security Policy (CSP) - это дополнительный уровень безопасности, позволяющий распознавать и устранять определённые типы атак, таких как Cross Site Scripting (XSS (en-US)) и атаки внедрения данных. Спектр применения этих атак включает, но не ограничивается кражей данных, подменой страниц и распространением зловредного ПО.</p>
    <p>CSP описывает безопасные источники загрузки ресурсов, устанавливает правила использования встроенных стилей, скриптов, а также динамической оценки JavaScript — например, с помощью eval. Загрузка с ресурсов, не входящих в «белый список», блокируется.</p>
    `,
  },

  {
    id: 245,
    title: 'Что такое requestAnimationFrame?',
    category: [QuizletQuestionCategoryEnum.frontend],
    level: 3,
    links: [
      {
        label: 'MDN',
        href: 'https://developer.mozilla.org/ru/docs/Web/API/window/requestAnimationFrame',
      },
    ],
    answer: `
    <p>window.requestAnimationFrame указывает браузеру на то, что вы хотите произвести анимацию, и просит его запланировать перерисовку на следующем кадре анимации. В качестве параметра метод получает функцию, которая будет вызвана перед перерисовкой</p>
    `,
  },

  {
    id: 246,
    title: 'Микросервисный подход в веб-разработке',
    category: [QuizletQuestionCategoryEnum.frontend],
    level: 3,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://dou.ua/lenta/articles/micro-frontend/#:~:text=%D0%9C%D0%B8%D0%BA%D1%80%D0%BE%D1%84%D1%80%D0%BE%D0%BD%D1%82%D0%B5%D0%BD%D0%B4%20(micro%20frontend)%20%E2%80%94%20%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%BD%D1%8B%D0%B9,%D1%81%20%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%D0%BC%20%D1%80%D0%B0%D0%B7%D0%BD%D1%8B%D1%85%20%D1%84%D1%80%D0%B5%D0%B9%D0%BC%D0%B2%D0%BE%D1%80%D0%BA%D0%BE%D0%B2%20(%D1%81%D0%BC.',
      },
    ],
    answer: `
    <p>Микросервисная архитектура — это полная противоположность монолитной архитектуры. Используя такой подход вместо одного большого приложения, мы создаем набор небольших слабосвязанных и легко заменяемых модулей, которые взаимодействуют друг с другом. Одно из главных достоинств микросервисной архитектуры — возможность использовать наилучший технический стек для каждой отдельной задачи.</p>
    <p>Микрофронтенд (micro frontend) — архитектурный подход, в котором независимые приложения собраны в одно большое приложение. Он дает возможность объединить в одном приложении разные виджеты или страницы, написанные разными командами с использованием разных фреймворков</p>
    <p>То есть, хедер может быть от ангуляра, сайдбар от вью а контент от реакта</p>
    <p>Способы создания:</p>
    <ul>
      <li>IFrames - это давняя технология, которая, несмотря на всю свою неактуальность, дает возможность построить микрофронтенд-архитектуру. Используя IFrame, каждый отдельный виджет можно поместить в IFrame, который загружает нужное приложение. При использовании такого подхода вы, скорее всего, столкнетесь со следующими проблемами: производительность и сложность поддержки.</li>
      <li>Библиотека Tailor.js</li>
      <li>Single-spa - это фреймворк, который дает возможность объединить разные приложения, независимо от используемой библиотеки или фреймворка, в одно целое. Под капотом single-spa набор существующих инструментов вместе с собственными решениями</li>
    </ul>
    `,
  },

  {
    id: 247,
    title: 'Порівняйте nextElementSibling та nextSibling',
    category: [QuizletQuestionCategoryEnum.frontend],
    level: 3,
    answer: `
    <p>nextSibling возвращает следующий объект Node, тогда как nextElementSibling возвращает следующий объект Element</p>
    <p>node может быть просто текстом</p>
    `,
  },

  {
    id: 248,
    title: 'Какие есть метрики сайта?',
    category: [QuizletQuestionCategoryEnum.frontend],
    level: 3,
    answer: `
    <p>Скорость загрузки первого экрана, производительность, скорость загрузки, посещения, клики, вовлеченность</p>
    `,
  },

  {
    id: 249,
    title: 'Методология git flow',
    category: [QuizletQuestionCategoryEnum.git],
    level: 3,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://www.atlassian.com/ru/git/tutorials/comparing-workflows/gitflow-workflow#:~:text=Git%2Dflow%20%E2%80%94%20%D0%B0%D0%BB%D1%8C%D1%82%D0%B5%D1%80%D0%BD%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F%20%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C%20%D0%B2%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F,%D0%92%D0%B8%D0%BD%D1%81%D0%B5%D0%BD%D1%82%D0%BE%D0%BC%20%D0%94%D1%80%D0%B8%D1%81%D1%81%D0%B5%D0%BD%D0%BE%D0%BC%20%D0%BD%D0%B0%20%D1%81%D0%B0%D0%B9%D1%82%D0%B5%20nvie.',
      },
    ],
    answer: `
      <p>Идея в том, что есть 2 основные ветки: main и develop. В девелоп кидаются все фичи. От девелоп они отбранчиваются. Потом от ветки develop создается ветка release мерджится в мейн каждый раз, но коммит будет названием версии</p>
    `,
  },

  {
    id: 250,
    title: 'Что означает требование делать squash commits во время rebase?',
    category: [QuizletQuestionCategoryEnum.git],
    level: 3,
    links: [
      {
        label: 'Ссылка 1',
        href: 'https://git-scm.com/book/ru/v2/%D0%98%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D1%8B-Git-%D0%9F%D0%B5%D1%80%D0%B5%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C-%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D0%B8',
      },
    ],
    answer: `
      <p>С помощью интерактивного режима команды rebase также можно объединить несколько коммитов в один. Git добавляет полезные инструкции в сообщение скрипта перебазирования</p>
      <p>Если вместо «pick» или «edit» вы укажете «squash», Git применит изменения из текущего и предыдущего коммитов и предложит вам объединить их сообщения. </p>
      <p>Когда вы сохраните скрипт и выйдете из редактора, Git применит изменения всех трёх коммитов и затем вернёт вас обратно в редактор, чтобы вы могли объединить сообщения коммитов</p>
      <p>После сохранения сообщения, вы получите один коммит, содержащий изменения всех трёх коммитов, существовавших ранее</p>
    `,
  },

  {
    id: 251,
    title: 'Расскажите об обобщённых типах (generics) в TypeScript',
    category: [QuizletQuestionCategoryEnum.typescript],
    level: 3,
    answer: `
      <p>Обобщённые типы (generics) позволяют создавать компоненты или функции, которые могут работать с различными типами, а не с каким-то одним. </p>
      <code>/** Объявление класса с параметром обобщённого типа */
        class Queue&lt;t&gt; {
        &nbsp;private data = [];
        &nbsp;push = (item: T) =&gt; this.data.push(item);
        &nbsp;pop = (): T =&gt; this.data.shift();
        }

        const queue = new Queue&lt;number&gt;();
        queue.push(0);
        queue.push("1"); // Ошибка : в такую очередь нельзя добавить строку, тут разрешено использовать лишь числа</code>
    `,
  },

  {
    id: 252,
    title:
      'Как в TypeScript реализовать свойства класса, являющиеся константами?',
    category: [QuizletQuestionCategoryEnum.typescript],
    level: 3,
    answer: `
      <p>В TypeScript, при объявлении свойств классов, нельзя использовать ключевое слово const. При попытке использования этого ключевого слова выводится следующее сообщение об ошибке: A class member cannot have the ‘const’ keyword. В TypeScript 2.0 имеется модификатор readonly, позволяющий создавать свойства класса, предназначенные только для чтения</p>
      <code>class MyClass {
        &nbsp;&nbsp;&nbsp;readonly myReadonlyProperty = 1;
       
        &nbsp;&nbsp;&nbsp;myMethod() {
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(this.myReadonlyProperty);
        &nbsp;&nbsp;&nbsp;}
       }
       
       new MyClass().myReadonlyProperty = 5; // ошибка, так как свойство предназначено только для чтения</code>
    `,
  },

  {
    id: 253,
    title: 'Что представляют собой .map-файлы в TypeScript?',
    category: [QuizletQuestionCategoryEnum.typescript],
    level: 3,
    answer: `
      <p>Файлы с расширением .map хранят карты кода (source map), которые содержат данные о соответствии кода, написанного на TypeScript, JavaScript-коду, созданному на его основе. С этим файлами могут работать многие отладчики (например — Visual Studio и инструменты разработчика Chrome). Это позволяет, в ходе отладки, работать с исходным кодом программ на TypeScript, а не с их JS-эквивалентами.</p>
    `,
  },

  {
    id: 254,
    title: 'Есть ли в предоставленном вам TypeScript-коде ошибки?',
    category: [QuizletQuestionCategoryEnum.typescript],
    level: 3,
    isPractise: true,
    answer: `
    <code>class Point {
      &nbsp;&nbsp;&nbsp;x: number;
      &nbsp;&nbsp;&nbsp;y: number;
     }
     
     interface Point3d extends Point {
      &nbsp;&nbsp;&nbsp;z: number;
     }
     
     let point3d: Point3d = {x: 1, y: 2, z: 3};</code>
     <p>Ошибок в этом коде нет. Объявление класса создаёт две сущности: это тип данных, используемый для создания экземпляров класса, и функция-конструктор. Так как классы создают типы данных, использовать их можно там же, где можно использовать интерфейсы.</p>
    `,
  },

  {
    id: 255,
    title: 'Расскажите об использовании декораторов свойств в TypeScript',
    category: [QuizletQuestionCategoryEnum.typescript],
    level: 3,
    answer: `
      <p>Декораторы можно использовать для изменения поведения классов, при этом ещё больше пользы от них можно получить при их использовании с каким-либо фреймворком. Например, если в вашем фреймворке есть методы, доступ к которым ограничен (скажем, они предназначены только для администратора), несложно будет написать декоратор метода @admin, который будет запрещать доступ к соответствующим методам пользователям, не являющимся администраторами. Можно создать декоратор @owner, который позволяет модифицировать объект только его владельцу. Вот как может выглядеть использование декораторов</p>
      <p>Декоратор — это специальный вид описания, который можно присоединить к декларации класса, метода, get свойства, свойства или параметра. Декораторы используют форму @expression, то есть при использовании ставится символ @ перед именем декоратора. Хотя по сути expression может быть любая функция. Эта функция будет вызвана в процессе выполнения программы, причем вызывающий код добавит аргументы с информацией о том объекте, который был задекорирован.</p>
      <p>Другими словами, декоратор — это способ добавить дополнительное поведение классу, функции, свойству или параметру. Это можно отнестик парадигме мета-программирования или декларативного программирования.</p>
      <p>Важно, что декоратор — это лишь функция. При использовании, среда исполнения сначала вызовет функцию-декоратор, и только потом будет выполнен основной сценарий объекта (если код декоратора содержит этот вызов). При наличии нескольких декораторов, они будет вызваны по очереди, сверху вниз.</p>
      <code>
        class TestServiceDeco { <br/>
            @LogTime() <br/>
            testLogging() { <br/>
                ... <br/>
            } <br/>
        } <br/>
        ... <br/>
        function LogTime() {<br/>
          return (target: Object, propertyName: string, descriptor: TypedPropertyDescriptor<Function>) => {<br/>
              const method = descriptor.value;<br/>
              descriptor.value = function(...args) {<br/>
                  console.time(propertyName || 'LogTime');<br/>
                  const result = method.apply(this, args);<br/>
                  console.timeEnd(propertyName || 'LogTime');<br/>
                  return result;<br/>
              };<br/>
          };<br/>
        }
      </code>
     
      `,
  },

  {
    id: 256,
    title: 'Ключевые слова module и namespace',
    category: [QuizletQuestionCategoryEnum.typescript],
    level: 3,
    links: [
      {
        label: 'Typescript Official',
        href: 'https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html',
      },
      {
        label: 'Ссылка 2',
        href: 'https://runebook.dev/ru/docs/typescript/namespaces-and-modules',
      },
    ],
    answer: `
      <p>Пространство имен (namespace) это конструкция, которая объявляется при помощи ключевого слова namespace и которая представляется в коде обычным JavaScript объектом</p>
      <p>Механизм пространства имен является решением такой проблемы, как коллизии в глобальном пространстве имен, дошедшего до наших дней из тех времён, когда ещё в спецификации JavaScript не было определено такое понятие, как модули. Простыми словами пространства имен, это совокупность обычной глобальной переменной и безымянного функционального выражения.</p>
      <p>До компиляции</p>
      <code>
        namespace NamespaceIdentifier { <br/>
          class PrivateClassIdentifier {} <br/>
          export class PublicClassIdentifier{} <br/>
        }
      </code>
      <p>После компиляции</p>
      <code>
        var NamespaceIdentifier; <br/>
        <br/>
        (function (NamespaceIdentifier) { <br/>
        <br/>
          class PrivateClassIdentifier { <br/>
          } <br/>
          class PublicClassIdentifier { <br/>
          } <br/>
          <br/>
          NamespaceIdentifier.PublicClassIdentifier = PublicClassIdentifier; <br/>
          <br/>
        })(NamespaceIdentifier || (NamespaceIdentifier = {}));
      </code>

      <p>Модули в TypeScript определяются с помощью ключевых слов export / import и представляют механизм определения связей между модулями. Данный механизм являются внутренним для TypeScript и не имеет никакого отношения к модулям es2015. В остальном они идентичны es2015 модулям, за исключением определения модуля по умолчанию (export default).</p>
      <p>Модули могут содержать как код,так и декларации.</p>
      <p>Пространства имен-это специфический для TypeScript способ организации кода.</p>
      `,
  },

  {
    id: 257,
    title:
      'Как сделать так, чтобы классы, объявленные в модуле, были бы доступны и за пределами этого модуля?',
    category: [QuizletQuestionCategoryEnum.typescript],
    level: 3,
    isPractise: true,
    answer: `
      <p>Классы, объявленные в модуле, доступны в пределах этого модуля. За его пределами доступ к ним получить нельзя.</p>
      <code>module Vehicle {
        &nbsp;&nbsp;&nbsp;class Car {
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constructor (
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public make: string, 
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public model: string) { }
        &nbsp;&nbsp;&nbsp;}
        &nbsp;&nbsp;&nbsp;var audiCar = new Car("Audi", "Q7");
       }
       // Это работать не будет
       var fordCar = Vehicle.Car("Ford", "Figo");</code>
       <p>В коде, приведённом выше, при попытке инициализации переменной fordCar произойдёт ошибка. Для того чтобы сделать класс, объявленный в модуле, доступным за пределами этого модуля, нужно воспользоваться ключевым словом export</p>
       <code>module Vehicle {
        &nbsp;&nbsp;&nbsp;export class Car {
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constructor (
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public make: string, 
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public model: string) { }
        &nbsp;&nbsp;&nbsp;}
        &nbsp;&nbsp;&nbsp;var audiCar = new Car("Audi", "Q7");
       }
       // Теперь этот фрагмент кода работает нормально
       var fordCar = Vehicle.Car("Ford", "Figo");</code>
      `,
  },

  {
    id: 258,
    title: 'Поддерживает ли TypeScript перегрузку функций?',
    category: [QuizletQuestionCategoryEnum.typescript],
    level: 3,
    answer: `
      <p>TypeScript поддерживает перегрузку функций, но реализация этого механизма отличается от той, которую можно видеть в других объектно-ориентированных языках. А именно, в TS создают лишь одну функцию и некоторое количество объявлений. Когда такой код компилируется в JavaScript, видимой оказывается лишь одна конкретная функция. Этот механизм работает из-за того, что JS-функции можно вызывать, передавая им разное количество параметров.</p>
      <code>class Foo {
        &nbsp;&nbsp;&nbsp;myMethod(a: string);
        &nbsp;&nbsp;&nbsp;myMethod(a: number);
        &nbsp;&nbsp;&nbsp;myMethod(a: number, b: string);
        &nbsp;&nbsp;&nbsp;myMethod(a: any, b?: string) {
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert(a.toString());
        &nbsp;&nbsp;&nbsp;}
       }</code>
      `,
  },

  {
    id: 259,
    title: 'Внешнее объявление переменной (ambient declaration) и declare',
    category: [QuizletQuestionCategoryEnum.typescript],
    level: 3,
    answer: `
      <p>Ключевое слово declare используется в TypeScript для объявления переменных, источником которых может служить некий файл, не являющийся TypeScript-файлом.</p>
      <p>Например, представим, что у нас имеется библиотека, которая называется myLibrary. У неё нет файла с объявлениями типов TypeScript, у неё имеется лишь пространство имён myLibrary в глобальном пространстве имён.</p>
      <p>Внешнее объявление переменной (ambient declaration) — это механизм, который позволяет сообщать компилятору TypeScript о том, что некий исходный код существует где-то за пределами текущего файла. Внешние объявления помогают интегрировать в TS-программы сторонние JavaScript-библиотеки.</p>
      <code>declare module Module_Name {}</code>
      `,
  },

  {
    id: 260,
    title: 'Что такое тип never?',
    category: [QuizletQuestionCategoryEnum.typescript],
    level: 3,
    answer: `
      <p>Тип never - примитивный тип, который олицетворяет значения, которых никогда не будет</p>
      <ul>
        <li>бесконечный цикл</li>
        <li>прерывание через throw new Error()</li>
        <li>"божественная" рекурсия</li>
      </ul>
      `,
  },

  {
    id: 261,
    title: 'Что такое keyof?',
    category: [QuizletQuestionCategoryEnum.typescript],
    level: 3,
    answer: `
      <p>keyof возвращает ключи типа</p>
      <code>
        type Point = { x: number, y: number }; <br/>
        type P = keyof Point; <br/>
        // P = x | y;
      </code>
      `,
  },

  {
    id: 262,
    title: 'Конструкция key in',
    category: [QuizletQuestionCategoryEnum.typescript],
    level: 3,
    answer: `
      <p>Конструкция, которая вмесие с keyof позволяет перебирать ключи</p>
      <code>
        type Scheme<T> = { <br/>
          [K in keyof T]: { <br/>
            value: T[K], <br/>
            checkL boolean; <br/>
          } <br/>
        }
      </code>
      `,
  },

  {
    id: 263,
    title: 'Отличие typeof от ReturnType',
    category: [QuizletQuestionCategoryEnum.typescript],
    level: 3,
    answer: `
      <p>typeof позволяет вернуть тип от какой-то переменной</p>
      <p>ReturnType позволяет вернуть тип возвращаемый функцией. Используется вместе с typeof</p>
      <code>
        type P = ReturnType<typeof someFunc>;
      </code>
      `,
  },

  {
    id: 264,
    title: 'Что такое Utility Types и какими они бывают',
    category: [QuizletQuestionCategoryEnum.typescript],
    level: 3,
    answer: `
      <p>Утилити типы - это помошники, которые позволяют создать новые типы из уже существующих</p>
      <ol>
        <li>
          <strong>Readonly</strong>
          <p>не дает мутировать уже созданный пот типу объект</p>
          <code>
            type Task = Readonly<{ id: number, name: string; }>;
          </code>
        </li>

        <li>
          <strong>Partial</strong>
          <p>делает все параметры и методы опциональными, как будто прописывает у каждого свойства "?"</p>
          <code>
            function partialUpdate(task: Task, patch: Partial<Task>) {...}
          </code>
        </li>

        <li>
          <strong>Required</strong>
          <p>делает все параметры обязательными, как будто убирает у каждого свойства "?"</p>
        </li>

        <li>
          <strong>Pick</strong>
          <p>Новый тип будет содержать только выбранные ключи типа</p>
          <code>
            type PublicUserFields = Pick<UserFields, 'username' | 'email' | 'bio'>
          </code>
        </li>

        <li>
          <strong>Omit</strong>
          <p>Новый тип будет содержать все ключи типа, но вычтет указанные</p>
          <code>
            type PublicUserFields = Pick<UserFields, 'salt' | 'password'>
          </code>
        </li>

        <li>
          <strong>Record</strong>
          <p>идентично { [key: string]: string }</p>
          <code>
            type Obj = Record<string, string>; <br/>
            type Obj2 = Record<'A' | 'B' | 'C', string> <br/>
            ... <br/>
            type ThemeParams = { fontSize: number, color: string }; <br/>
            type Theme = 'light' | 'dark'; <br/>
            type AppTheme = Record<Theme. ThemeParams>;
          </code>
        </li>

        <li>
          <strong>Exclude</strong>
          <p>Похож на Omit, но другая запись</p>
          <code>
            type UserSchemaType = { <br/>
              username: string; <br/>
              email: string; <br/>
              bio: string; <br/>
              id: number; <br/>
            } <br/>
            <br/>
            type PublicFields = Exclude<keyof UserSchemaType, 'bio' | 'id'>; <br/>
            // либо <br/>
            type PublicFields = Exclude<'username' | 'email' | 'bio' | 'id', 'bio' | 'id'>;
          </code>
        </li>

        <li>
          <strong>Extract</strong>
          <p>Сравнивает ключи и выдает общие</p>
          <code>
            type Intersection = Extract<'id' | 'name', 'name' | 'age'>; <br/>
            // либо <br/>
            type I = Extract<keyof Task, keyof UserSchemaType>;
          </code>
        </li>

        <li>
          <strong>NonNullable</strong>
          <p>Убирает из типа и его перечисления undefined и null</p>
        </li>

        <li>
          <strong>ReturnType</strong>
          <p>Позволяет вернуть тип возвращаемый функцией. Используется вместе с typeof</p>
          <code>
            type P = ReturnType<typeof someFunc>;
          </code>
        </li>

        <li>
          <strong>Parameters</strong>
          <p>Позволяет вернуть тип аргументов, передаваемых в функцию. Используется вместе с typeof</p>
          <code>
            type Input = Parameters<typeof someFunc>;
          </code>
        </li>

        <li>
          <strong>ConstructorParameters</strong>
          <p>Позволяет вернуть тип аргументов, передаваемых в функцию-конструктор. Используется вместе с typeof</p>
          <code>
            type Input = Parameters<typeof myClass>;
          </code>
        </li>

        <li>
          <strong>Awaited</strong>
          <p>Развернет тип промиса и выдаст его результат</p>
          <code>
            type FetchResult = Awaited<typeof myPromise>;
          </code>
        </li>

        <li>
          <strong>Строковые Uppercase, Lowercase, Capitalize, Uncapitalizee</strong>
          <p>Превращает все перечесления в нудный регистр</p>
          <code>
            type Name = Uppercase<Names>;
          </code>
        </li>
      </ol>
      `,
  },

  {
    id: 265,
    title: 'Напишите deep clone для объекта',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 3,
    isPractise: true,
    answer: `
      <code>
        function dup(o) { <br/>
          // "string", number, boolean <br/>
          if(typeof(o) != "object") { <br/>
              return o; <br/>
          } <br/>
          <br/>
          // null <br/>
          if(!o) { <br/>
              return o; // null <br/>
          } <br/>
          <br/>
          var r = (o instanceof Array) ? [] : {}; <br/>
          for(var i in o) { <br/>
              if(o.hasOwnProperty(i)) { <br/>
                  r[i] = dup(o[i]); <br/>
              } <br/>
          } <br/>
          return r; <br/>
        }
      </code>
      `,
  },

  {
    id: 266,
    title: 'Способы поменять местами значения переменных',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 3,
    links: [{ label: 'Ссылка 1', href: 'https://habr.com/ru/post/657625/' }],
    answer: `
      <ul>
        <li>Через временную переменную</li>
        <li>Через матичатические конструкции</li>
        <li>Через деструктуризацию</li>
      </ul>
      `,
  },

  {
    id: 267,
    title:
      'Напишите функцию Sleep (ms), которая останавливает выполнение async-функции на заданный промежуток времени.',
    category: [QuizletQuestionCategoryEnum.javascript],
    level: 3,
    answer: `
      <code>
        let sleep = ms => new Promise(res=>setTimeout(res,ms)); <br/>
        <br/>
        async function fx(){ <br/>
          console.log(1); <br/>
          await sleep(3000); <br/>
          console.log(2); <br/>
        } <br/>
        <br/>
        fx();
      </code>
      <p>или</p>
      <code>
        let sleep=ms=>{ <br/>
          let d=Date.now(); <br/>
          while(Date.now()-d<ms){} <br/>
        } <br/>
        <br/>
        console.log(1); <br/>
        sleep(3000); <br/>
        console.log(2);
      </code>
      `,
  },
];
